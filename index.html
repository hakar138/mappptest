<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SecureHat — Private Location Sharing & Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        /* Existing styles remain, adding new styles for SOS timer and UI improvements */
        
        /* SOS Timer Overlay */
        .sos-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(232, 65, 24, 0.9);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
            animation: pulseBackground 2s infinite;
        }
        
        @keyframes pulseBackground {
            0% { background-color: rgba(232, 65, 24, 0.9); }
            50% { background-color: rgba(232, 65, 24, 0.7); }
            100% { background-color: rgba(232, 65, 24, 0.9); }
        }
        
        .sos-timer {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .sos-instructions {
            font-size: 1.2rem;
            max-width: 500px;
            margin-bottom: 20px;
        }
        
        .movement-feedback {
            font-size: 1.1rem;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        
        .sos-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* Host-specific UI */
        .host-badge {
            background: #fbc531;
            color: #000;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: bold;
        }
        
        .host-exempt {
            background: #4cd137;
        }
        
        .host-danger {
            background: #e84118;
            color: white;
        }
        
        /* Improved chat UI */
        .chat-templates {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .chat-template-btn {
            padding: 6px 10px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-template-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .message-status {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Map improvements */
        .map-controls {
            position: absolute;
            bottom: 20px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .map-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        
        /* Original location marker */
        .origin-marker {
            border: 2px solid #e84118;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        /* Responsive improvements */
        @media (max-width: 600px) {
            .chat-input-row {
                flex-direction: column;
            }
            
            .chat-send {
                width: 100%;
            }
            
            .sos-timer {
                font-size: 2rem;
            }
            
            .sos-instructions {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Existing HTML structure remains the same -->
    
    <!-- SOS Timer Overlay (initially hidden) -->
    <div id="sos-overlay" class="sos-overlay hidden">
        <h2>EMERGENCY SOS TIMER ACTIVE</h2>
        <div id="sos-timer" class="sos-timer">01:30</div>
        <div id="sos-instructions" class="sos-instructions">
            Move at least 1 meter from your current position to cancel automatic SOS
        </div>
        <div id="movement-feedback" class="movement-feedback">
            No significant movement detected
        </div>
        <div class="sos-controls">
            <button id="sos-cancel-btn" class="btn">Cancel SOS</button>
            <button id="sos-send-now-btn" class="btn btn-stop">Send SOS Now</button>
        </div>
    </div>

    <!-- Rest of the HTML remains the same -->
</div>

<script>
/* ========= SOS Timer Implementation ========= */
let sosTimerInterval = null;
let sosTimeRemaining = 90; // 90 seconds
let sosInitialPosition = null;
let movementWatchId = null;
let accelerometerWatchId = null;
let movementDetected = false;
let movementSamples = [];
let hostExempt = false;

// Initialize SOS functionality
function initSOS() {
    // Check if device is host (exempt from auto-SOS)
    hostExempt = isHostDevice();
    
    // Add event listener to SOS button
    document.getElementById('sos-button').addEventListener('click', startSOSTimer);
    
    // Add event listeners to SOS control buttons
    document.getElementById('sos-cancel-btn').addEventListener('click', cancelSOS);
    document.getElementById('sos-send-now-btn').addEventListener('click', sendSOSImmediately);
    
    // Add chat templates
    addChatTemplates();
    
    // Add map controls
    addMapControls();
}

// Start the SOS timer
function startSOSTimer() {
    if (sosTimerInterval) {
        showNotification('SOS timer already active');
        return;
    }
    
    // Record initial position
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            position => {
                sosInitialPosition = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    timestamp: Date.now()
                };
                
                // Add origin marker to map
                addOriginMarker(sosInitialPosition);
                
                // Start the timer
                sosTimeRemaining = 90;
                updateSOSTimerDisplay();
                document.getElementById('sos-overlay').classList.remove('hidden');
                
                // Start movement monitoring
                startMovementMonitoring();
                
                // Start the countdown
                sosTimerInterval = setInterval(() => {
                    sosTimeRemaining--;
                    updateSOSTimerDisplay();
                    
                    if (sosTimeRemaining <= 0) {
                        clearInterval(sosTimerInterval);
                        sosTimerInterval = null;
                        
                        // Timer expired - check if movement was detected
                        if (movementDetected) {
                            cancelSOS();
                        } else {
                            // Host exemption check
                            if (hostExempt) {
                                showNotification('Host is exempt from automatic SOS - please send manual SOS if needed');
                                document.getElementById('sos-overlay').classList.add('hidden');
                                stopMovementMonitoring();
                            } else {
                                sendSOS();
                            }
                        }
                    }
                    
                    // Pulsing effect when time is low
                    if (sosTimeRemaining <= 10) {
                        document.getElementById('sos-timer').style.animation = 'pulse 0.5s infinite';
                    }
                }, 1000);
                
                // Log timer start
                logSOSEvent('timer_start', {
                    position: sosInitialPosition,
                    hostExempt: hostExempt
                });
            },
            error => {
                showNotification('Could not get location for SOS timer', true);
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    } else {
        showNotification('Geolocation not available', true);
    }
}

// Update SOS timer display
function updateSOSTimerDisplay() {
    const minutes = Math.floor(sosTimeRemaining / 60);
    const seconds = sosTimeRemaining % 60;
    document.getElementById('sos-timer').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Start monitoring movement
function startMovementMonitoring() {
    movementDetected = false;
    movementSamples = [];
    
    // Watch position for movement detection
    if (navigator.geolocation) {
        movementWatchId = navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handlePositionError,
            { 
                enableHighAccuracy: true, 
                maximumAge: 3000, 
                timeout: 10000 
            }
        );
    }
    
    // Watch device motion for accelerometer data (if available)
    if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', handleDeviceMotion);
    }
}

// Handle position updates for movement detection
function handlePositionUpdate(position) {
    if (!sosInitialPosition) return;
    
    const currentPos = {
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        accuracy: position.coords.accuracy,
        timestamp: Date.now()
    };
    
    // Calculate distance from initial position
    const distance = calculateDistance(
        sosInitialPosition.latitude, 
        sosInitialPosition.longitude,
        currentPos.latitude,
        currentPos.longitude
    );
    
    // Update movement feedback
    document.getElementById('movement-feedback').textContent = 
        `Movement detected: ${(distance * 100).toFixed(0)} cm (Accuracy: ±${currentPos.accuracy.toFixed(1)}m)`;
    
    // Check if movement exceeds threshold (1 meter)
    if (distance >= 1.0 && currentPos.accuracy <= 20) {
        movementDetected = true;
        document.getElementById('movement-feedback').textContent += ' - SOS will be canceled!';
        cancelSOS();
    }
    
    // Store sample for analysis
    movementSamples.push({
        position: currentPos,
        distance: distance,
        timestamp: Date.now()
    });
    
    // Keep only recent samples (last 10 seconds)
    const tenSecondsAgo = Date.now() - 10000;
    movementSamples = movementSamples.filter(s => s.timestamp > tenSecondsAgo);
}

// Handle device motion for step detection
function handleDeviceMotion(event) {
    const acceleration = event.accelerationIncludingGravity;
    if (!acceleration) return;
    
    // Calculate magnitude of acceleration
    const magnitude = Math.sqrt(
        acceleration.x * acceleration.x +
        acceleration.y * acceleration.y +
        acceleration.z * acceleration.z
    );
    
    // Simple step detection - look for peaks in acceleration
    if (movementSamples.length > 0) {
        const lastSample = movementSamples[movementSamples.length - 1];
        const accelChange = Math.abs(magnitude - (lastSample.acceleration || 0));
        
        if (accelChange > 2.0) {
            // Significant acceleration change detected - possible step
            movementDetected = true;
            document.getElementById('movement-feedback').textContent += ' (Motion detected)';
        }
    }
    
    // Store acceleration with position samples
    if (movementSamples.length > 0) {
        movementSamples[movementSamples.length - 1].acceleration = magnitude;
    }
}

// Handle position errors
function handlePositionError(error) {
    console.error('Position error:', error);
    document.getElementById('movement-feedback').textContent = 
        'High-accuracy location unavailable - movement detection may be less precise';
}

// Stop movement monitoring
function stopMovementMonitoring() {
    if (movementWatchId && navigator.geolocation) {
        navigator.geolocation.clearWatch(movementWatchId);
        movementWatchId = null;
    }
    
    if (window.DeviceMotionEvent) {
        window.removeEventListener('devicemotion', handleDeviceMotion);
    }
}

// Cancel SOS
function cancelSOS() {
    if (sosTimerInterval) {
        clearInterval(sosTimerInterval);
        sosTimerInterval = null;
    }
    
    stopMovementMonitoring();
    
    document.getElementById('sos-overlay').classList.add('hidden');
    showNotification('Movement detected. SOS canceled.');
    
    // Remove origin marker
    removeOriginMarker();
    
    // Log cancellation
    logSOSEvent('sos_canceled', {
        movementDetected: movementDetected,
        finalPosition: movementSamples.length > 0 ? movementSamples[movementSamples.length - 1].position : null
    });
}

// Send SOS immediately
function sendSOSImmediately() {
    if (sosTimerInterval) {
        clearInterval(sosTimerInterval);
        sosTimerInterval = null;
    }
    
    stopMovementMonitoring();
    sendSOS();
}

// Send SOS emergency
function sendSOS() {
    // Get current position for SOS
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            position => {
                const sosData = {
                    type: 'sos',
                    clientAlias: myAlias,
                    position: {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    },
                    timestamp: Date.now(),
                    hostExempt: hostExempt,
                    automatic: !movementDetected
                };
                
                // Send to peers
                if (conn && conn.open) {
                    safeSend(sosData);
                }
                
                // Show confirmation
                showNotification('SOS emergency sent!', false);
                
                // Log SOS event
                logSOSEvent('sos_sent', sosData);
                
                // Close overlay
                document.getElementById('sos-overlay').classList.add('hidden');
                
                // Remove origin marker
                removeOriginMarker();
            },
            error => {
                showNotification('Could not get location for SOS', true);
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    }
}

// Check if device is host (exempt from auto-SOS)
function isHostDevice() {
    // Check user agent for desktop/laptop indicators
    const userAgent = navigator.userAgent.toLowerCase();
    const isDesktop = !/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    
    // Additional check for screen size (laptops typically have larger screens)
    const isLargeScreen = window.innerWidth >= 1024;
    
    // Could also check for specific host role from server or localStorage
    const storedRole = localStorage.getItem('user_role');
    const isHostRole = storedRole === 'host' || isHost;
    
    return isDesktop && isLargeScreen && isHostRole;
}

// Add origin marker to map
function addOriginMarker(position) {
    if (window.originMarker) {
        map.removeLayer(window.originMarker);
    }
    
    window.originMarker = L.circleMarker([position.latitude, position.longitude], {
        className: 'origin-marker',
        color: '#e84118',
        fillColor: '#e84118',
        fillOpacity: 0.3,
        radius: 10
    }).addTo(map);
    
    window.originMarker.bindPopup('SOS origin position').openPopup();
}

// Remove origin marker
function removeOriginMarker() {
    if (window.originMarker) {
        map.removeLayer(window.originMarker);
        window.originMarker = null;
    }
}

// Log SOS events
function logSOSEvent(type, data) {
    const event = {
        type: type,
        timestamp: new Date().toISOString(),
        localTime: new Date().toLocaleString(),
        data: data
    };
    
    console.log('SOS Event:', event);
    
    // Store in localStorage for persistence
    const existingLogs = JSON.parse(localStorage.getItem('sos_logs') || '[]');
    existingLogs.push(event);
    localStorage.setItem('sos_logs', JSON.stringify(existingLogs));
}

// Add chat templates
function addChatTemplates() {
    const chatTemplates = [
        "I'm moving to a safer location",
        "I'm safe",
        "Need assistance",
        "Host flagged - manual response required"
    ];
    
    const templatesContainer = document.createElement('div');
    templatesContainer.className = 'chat-templates';
    
    chatTemplates.forEach(template => {
        const btn = document.createElement('button');
        btn.className = 'chat-template-btn';
        btn.textContent = template;
        btn.addEventListener('click', () => {
            chatInput.value = template;
            chatInput.focus();
        });
        templatesContainer.appendChild(btn);
    });
    
    // Insert templates before chat input
    const chatContainer = document.querySelector('.chat-card');
    chatContainer.insertBefore(templatesContainer, chatContainer.querySelector('.chat-input-row'));
}

// Add map controls
function addMapControls() {
    const controlsContainer = document.createElement('div');
    controlsContainer.className = 'map-controls';
    
    // Zoom to user button
    const zoomToUserBtn = document.createElement('div');
    zoomToUserBtn.className = 'map-control-btn';
    zoomToUserBtn.innerHTML = '<i class="fas fa-user"></i>';
    zoomToUserBtn.title = 'Zoom to my location';
    zoomToUserBtn.addEventListener('click', () => {
        if (myMarker) {
            map.setView(myMarker.getLatLng(), 16);
        }
    });
    controlsContainer.appendChild(zoomToUserBtn);
    
    // Zoom to all markers button
    const zoomToAllBtn = document.createElement('div');
    zoomToAllBtn.className = 'map-control-btn';
    zoomToAllBtn.innerHTML = '<i class="fas fa-users"></i>';
    zoomToAllBtn.title = 'Zoom to all users';
    zoomToAllBtn.addEventListener('click', () => {
        const markers = [];
        if (myMarker) markers.push(myMarker.getLatLng());
        if (peerMarker) markers.push(peerMarker.getLatLng());
        
        if (markers.length > 0) {
            const bounds = L.latLngBounds(markers);
            map.fitBounds(bounds, { padding: [50, 50] });
        }
    });
    controlsContainer.appendChild(zoomToAllBtn);
    
    // Add to map
    map.getContainer().appendChild(controlsContainer);
}

// Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth radius in meters
    const φ1 = lat1 * Math.PI/180;
    const φ2 = lat2 * Math.PI/180;
    const Δφ = (lat2 - lat1) * Math.PI/180;
    const Δλ = (lon2 - lon1) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Initialize SOS functionality when DOM is loaded
document.addEventListener('DOMContentLoaded', initSOS);

/* ========= Host Flagging Functionality ========= */
function flagHostInDanger() {
    if (!isHost) {
        showNotification('Only participants can flag the host as in danger');
        return;
    }
    
    // Send host danger flag to peers
    const flagData = {
        type: 'host_danger',
        clientAlias: myAlias,
        timestamp: Date.now(),
        message: 'Host flagged in danger - manual response required'
    };
    
    if (conn && conn.open) {
        safeSend(flagData);
    }
    
    showNotification('Host flagged as in danger');
}

// Handle host danger flag
function handleHostDangerFlag(data) {
    // Update host UI to show danger status
    const hostIndicator = document.getElementById('host-indicator');
    if (hostIndicator) {
        hostIndicator.textContent = 'Host — In Danger (manual SOS required)';
        hostIndicator.classList.add('host-danger');
    }
    
    // Show alert in chat
    appendMessage(data.message, false, true);
    
    // Show notification
    showNotification('Host flagged in danger - manual response required', true);
}

// Modify the data handler to process host danger flags
// Add this to the existing setupDataChannel function:
/*
else if(data.type === 'host_danger') {
    handleHostDangerFlag(data);
}
*/

/* ========= UI Improvements ========= */
// Add message status indicators
function updateMessageStatus(messageId, status) {
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
        const statusElement = messageElement.querySelector('.message-status');
        if (statusElement) {
            statusElement.innerHTML = `<i class="fas fa-${getStatusIcon(status)}"></i> ${status}`;
        }
    }
}

function getStatusIcon(status) {
    switch(status) {
        case 'sending': return 'clock';
        case 'delivered': return 'check';
        case 'read': return 'check-double';
        default: return 'info';
    }
}

// Improve mobile chat input
function improveChatInput() {
    if ('maxHeight' in document.documentElement.style) {
        chatInput.style.minHeight = '50px';
        chatInput.style.maxHeight = '120px';
        chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    }
}

// Initialize UI improvements
document.addEventListener('DOMContentLoaded', improveChatInput);
</script>
</body>
</html>
