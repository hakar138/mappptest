<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SecureHat â€” Private Location Sharing & Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif }
        body { min-height: 100vh; background: linear-gradient(135deg, #0d1c33, #10294f); color: #fff; padding: 16px 12px; overflow-x: hidden }
        .container { max-width: 980px; margin: 0 auto }
        header { text-align: center; margin-bottom: 24px }
        .logo { display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 10px }
        .logo-icon { width: 54px; height: 54px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg, #ff7e5f, #feb47b); box-shadow: 0 6px 20px rgba(0,0,0,.25) }
        .logo-text { font-weight: 800; font-size: 1.8rem; background: linear-gradient(90deg, #ff7e5f, #feb47b); -webkit-background-clip: text; color: transparent; letter-spacing: 1px }
        h1 { font-size: 1.6rem; margin-bottom: 8px }
        .subtitle { opacity: .9; font-size: 1.05rem; max-width: 600px; margin: 0 auto }
        .privacy-notice { background: rgba(255,255,255,.05); padding: 14px; border-radius: 10px; border-left: 4px solid #4cd137; margin: 16px 0; display: flex; align-items: center; gap: 12px; font-size: 0.95rem }
        .card { background: rgba(255,255,255,.04); padding: 20px; border-radius: 14px; margin: 14px 0; border: 1px solid rgba(255,255,255,.08); box-shadow: 0 6px 20px rgba(0,0,0,.2); transition: transform 0.3s ease }
        .card:hover { transform: translateY(-3px); box-shadow: 0 10px 25px rgba(0,0,0,.25) }
        .card-title { display: flex; align-items: center; gap: 10px; color: #feb47b; font-weight: 700; margin-bottom: 14px; font-size: 1.25rem }
        .form-group { margin-bottom: 16px }
        .form-label { display: block; font-weight: 700; margin-bottom: 8px; font-size: 1rem }
        .form-note { font-size: .9rem; opacity: .85; margin-top: 8px; line-height: 1.5 }
        .form-control { width: 100%; padding: 14px; border-radius: 12px; border: none; background: rgba(255,255,255,.05); color: #fff; font-size: 1.05rem; transition: all 0.3s ease }
        .form-control:focus { outline: 2px solid rgba(255,126,95,.4); background: rgba(255,255,255,.08); box-shadow: 0 0 0 4px rgba(255,126,95,.25) }
        .btn-container { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 8px }
        @media (max-width:720px) { .btn-container { grid-template-columns:1fr } }
        .btn { padding: 14px; border-radius: 12px; border: none; cursor: pointer; font-weight: 700; background: linear-gradient(45deg,#ff7e5f,#feb47b); color: #fff; display: inline-flex; align-items: center; gap: 10px; justify-content: center; font-size: 1rem; transition: all 0.2s ease; box-shadow: 0 4px 8px rgba(0,0,0,.15) }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 8px 15px rgba(0,0,0,.2) }
        .btn:active { transform: translateY(1px) }
        .btn-outline { background: transparent; border: 2px solid #ff7e5f; color: #ff7e5f }
        .btn-stop { background: linear-gradient(45deg,#e84118,#c23616); color: #fff }
        .btn-update { background: linear-gradient(45deg, #4facfe, #00f2fe); }
        .btn-unshare { background: linear-gradient(45deg, #9c88ff, #8c7ae6); }
        .small-btn { padding: 10px 14px; font-size: .95rem; border-radius: 10px }
        .code-row { display: flex; gap: 12px; align-items: center; margin-top: 12px }
        .code-input { flex: 1; padding: 14px; border-radius: 12px; border: none; background: rgba(255,255,255,.04); text-align: center; letter-spacing: 3px; font-weight: 700; color: #fff; font-size: 1.05rem }
        .code-meta { font-size: .9rem; color: rgba(255,255,255,.85); margin-top: 8px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center }
        .map-container { height: 320px; border-radius: 14px; overflow: hidden; margin-top: 16px; border: 2px solid rgba(255,255,255,.08) }
        #map { width: 100%; height: 100% }
        .user-list { display: grid; grid-template-columns: repeat(auto-fill,minmax(280px,1fr)); gap: 14px; margin-top: 16px }
        .user-card { display: flex; gap: 14px; align-items: center; padding: 14px; border-radius: 12px; background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.05); transition: all 0.3s ease }
        .user-card:hover { background: rgba(255,255,255,.07); transform: translateY(-3px); box-shadow: 0 6px 12px rgba(0,0,0,.2) }
        .user-avatar { width: 56px; height: 56px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: linear-gradient(45deg,#4facfe,#00f2fe); font-weight: 800; font-size: 1.4rem }
        .user-info .user-name { font-weight: 700; font-size: 1.05rem; margin-bottom: 4px }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; background: #4cd137; display: inline-block; margin-right: 10px }
        .chat-card { display: flex; flex-direction: column; height: 300px }
        .chat-messages { flex: 1; overflow: auto; padding: 12px; border-radius: 10px; background: rgba(0,0,0,0.15); margin-bottom: 10px; font-size: 1rem; display: flex; flex-direction: column; gap: 8px }
        .chat-input-row { display: flex; gap: 10px }
        .chat-input { flex: 1; padding: 12px; border-radius: 10px; border: none; font-size: 1rem; background: rgba(255,255,255,.05); color: #fff }
        .chat-send { padding: 12px 16px; border-radius: 10px; border: none; background: linear-gradient(45deg,#4facfe,#00f2fe); color: #fff; cursor: pointer; font-size: 1rem; transition: all 0.2s ease; min-width: 100px }
        .chat-send:hover { background: linear-gradient(45deg,#3a9cf7,#00d9f2) }
        .notification { position: fixed; right: 16px; top: 16px; background: rgba(0,0,0,.5); padding: 12px 18px; border-radius: 12px; backdrop-filter: blur(6px); transform: translateX(120%); transition: transform .35s; z-index: 9000; color: #fff; border-left: 4px solid #4cd137; max-width: calc(100% - 32px); font-size: 0.95rem; display: flex; align-items: center; gap: 10px }
        .notification.show { transform: translateX(0) }
        .notification.error { border-left-color: #e84118 }
        footer { text-align: center; margin-top: 24px; font-size: 0.9rem; opacity: .8; padding: 16px 0 }
        #join-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.7); z-index: 10000; pointer-events: none }
        #join-modal.show { display: flex; pointer-events: auto }
        .join-box { width: 90%; max-width: 500px; background: linear-gradient(135deg,#0e2340,#102e4a); padding: 24px; border-radius: 16px; border: 1px solid rgba(255,255,255,.08); box-shadow: 0 25px 60px rgba(0,0,0,.6); animation: modalIn 0.4s ease }
        #stop-confirmation { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.75); z-index: 9999; pointer-events: none }
        #stop-confirmation.show { display: flex; pointer-events: auto }
        .confirmation-box { width: 90%; max-width: 540px; background: linear-gradient(135deg,#11264a,#183054); border-radius: 16px; padding: 24px; border: 1px solid rgba(255,255,255,.08); box-shadow: 0 22px 50px rgba(0,0,0,.7); text-align: center; pointer-events: auto; animation: modalIn 0.4s ease }
        .confirmation-buttons { display: flex; gap: 14px; justify-content: center; margin-top: 20px }
        .hidden { display: none !important }
        .message-me { align-self: flex-end; background: linear-gradient(45deg,#ff7e5f,#feb47b); color: #000; padding: 10px 14px; border-radius: 14px; max-width: 85%; font-size: 0.95rem; animation: fadeIn 0.3s ease }
        .message-peer { align-self: flex-start; background: rgba(255,255,255,0.1); color: #fff; padding: 10px 14px; border-radius: 14px; max-width: 85%; font-size: 0.95rem; animation: fadeIn 0.3s ease }
        .message-system { text-align: center; color: rgba(255,255,255,0.8); font-style: italic; font-size: 0.9rem; margin: 12px 0; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.05) }
        .btn-reconnect { background: linear-gradient(45deg, #4facfe, #00f2fe); }
        .host-badge { background: #fbc531; color: #000; font-size: 0.8rem; padding: 4px 8px; border-radius: 10px; margin-left: 8px; font-weight: bold }
        @media (max-width: 600px) {
            body { padding: 14px 10px; }
            .logo { flex-direction: column; text-align: center; }
            .logo-icon { margin-bottom: 8px; }
            .card { padding: 16px; }
            .btn-container { grid-template-columns: 1fr; }
            .code-row { flex-direction: column; }
            .code-row button { width: 100%; }
            .confirmation-buttons { flex-direction: column; }
            .confirmation-buttons button { width: 100%; }
            .chat-card { height: 260px; }
            .map-container { height: 260px; }
            .user-list { grid-template-columns: 1fr; }
            .privacy-notice { flex-direction: column; text-align: center; }
            .code-meta { flex-direction: column; align-items: flex-start; gap: 6px; }
            .chat-input-row { flex-direction: column; }
            .chat-send { width: 100%; }
            .join-box { padding: 18px; }
            .confirmation-box { padding: 20px; }
        }
        @media (max-width: 400px) {
            .logo-text { font-size: 1.5rem; }
            h1 { font-size: 1.4rem; }
            .card-title { font-size: 1.1rem; }
            .btn { padding: 12px; font-size: 0.95rem; }
            .form-control { padding: 12px; }
            .notification { padding: 10px 14px; font-size: 0.9rem; }
        }
        .toggle-container { display: flex; align-items: center; gap: 12px; margin-top: 14px; }
        .switch { position: relative; display: inline-block; width: 54px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background: linear-gradient(45deg,#ff7e5f,#feb47b); }
        input:checked + .slider:before { transform: translateX(26px); }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes modalIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 0.3s ease forwards; }
        .session-info { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; background: rgba(255,255,255,.04); padding: 12px; border-radius: 10px; margin-bottom: 16px }
        .session-timer { display: flex; align-items: center; gap: 8px; font-weight: 600; color: #feb47b }
        .session-status { display: flex; align-items: center; gap: 10px; }
        .status-indicator { width: 14px; height: 14px; border-radius: 50%; background: #fbc531 }
        .status-indicator.connected { background: #4cd137 }
        .session-role { background: rgba(251, 197, 49, 0.15); color: #fbc531; padding: 4px 10px; border-radius: 6px; font-size: 0.85rem }
        .location-sharing { display: flex; align-items: center; gap: 8px; margin-top: 8px }
        .location-sharing .dot { width: 10px; height: 10px; border-radius: 50%; background: #e84118 }
        .location-sharing.active .dot { background: #4cd137 }
        .location-sharing.active { color: #4cd137 }
        .user-card .location-sharing { margin-top: 4px }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 180px; background-color: rgba(0,0,0,0.8); color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; font-size: 0.85rem }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1 }
        .rejoin-notice { background: rgba(255,255,255,.05); padding: 10px; border-radius: 10px; border-left: 4px solid #4facfe; margin: 12px 0; display: flex; align-items: center; gap: 8px; font-size: 0.9rem }
        .duration-badge { background: rgba(79, 172, 254, 0.2); color: #4facfe; padding: 4px 8px; border-radius: 20px; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 4px }
        /* New styles for voice chat and danger features */
        .voice-chat-container { display: flex; gap: 10px; margin-top: 10px; align-items: center; }
        .voice-btn { background: linear-gradient(45deg, #9c88ff, #8c7ae6); }
        .voice-btn.recording { background: linear-gradient(45deg, #e84118, #c23616); animation: pulse 1s infinite; }
        .voice-message { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-radius: 18px; background: rgba(79, 172, 254, 0.2); margin: 8px 0; }
        .voice-message.me { background: rgba(255, 126, 95, 0.2); align-self: flex-end; }
        .voice-player { flex: 1; }
        .sos-btn { background: linear-gradient(45deg, #e84118, #c23616); margin-top: 10px; }
        .danger-status { color: #e84118; font-weight: bold; }
        .danger-animation { animation: danger-pulse 2s infinite; }
        .coordinates-display { font-size: 0.85rem; margin-top: 8px; opacity: 0.8; }
        .chat-message-time { font-size: 0.7rem; opacity: 0.7; margin-top: 4px; }
        .chat-message-container { display: flex; flex-direction: column; max-width: 85%; }
        .chat-message-container.me { align-self: flex-end; }
        .chat-message-container.peer { align-self: flex-start; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes danger-pulse {
            0% { background-color: rgba(232, 65, 24, 0.1); }
            50% { background-color: rgba(232, 65, 24, 0.3); }
            100% { background-color: rgba(232, 65, 24, 0.1); }
        }
        .user-card.danger { border: 2px solid #e84118; background: rgba(232, 65, 24, 0.1); }
        .danger-icon { color: #e84118; margin-left: 5px; }
        /* Improved chat UI */
        .chat-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .chat-tabs { display: flex; gap: 5px; }
        .chat-tab { padding: 5px 10px; border-radius: 15px; background: rgba(255,255,255,0.05); cursor: pointer; }
        .chat-tab.active { background: rgba(79, 172, 254, 0.3); }
        /* SOS Timer Overlay */
        .sos-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(232, 65, 24, 0.95);
            color: white;
            padding: 15px;
            text-align: center;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            animation: slideDown 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        .sos-timer {
            font-size: 2.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .sos-progress {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        .sos-progress-bar {
            height: 100%;
            background: #fff;
            width: 100%;
            transition: width 1s linear;
        }
        .sos-instructions {
            font-size: 1.1rem;
            margin: 10px 0;
            max-width: 80%;
        }
        .sos-movement-indicator {
            font-size: 1rem;
            margin: 10px 0;
            font-weight: 500;
        }
        .sos-btn-container {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .sos-cancel-btn {
            background: linear-gradient(45deg, #4cd137, #44bd32);
        }
        .sos-send-btn {
            background: linear-gradient(45deg, #e84118, #c23616);
        }
        /* Host-specific styles */
        .host-exempt-badge {
            background: #3498db;
            color: white;
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }
        .host-in-danger {
            background: #e84118;
            color: white;
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 12px;
            margin-left: 8px;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        /* Quick action buttons in chat */
        .quick-action-container {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .quick-action-btn {
            padding: 8px 12px;
            border-radius: 20px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .quick-action-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        .quick-action-btn.safe {
            background: rgba(76, 209, 55, 0.2);
            color: #4cd137;
        }
        .quick-action-btn.moving {
            background: rgba(255, 126, 95, 0.2);
            color: #ff7e5f;
        }
        .quick-action-btn.host-flag {
            background: rgba(232, 65, 24, 0.2);
            color: #e84118;
        }
        /* Original and current location markers */
        .original-location-marker {
            background-color: #e84118;
        }
        .current-location-marker {
            background-color: #4cd137;
        }
        /* Low time warning */
        .sos-timer.low-time {
            animation: pulseRed 0.5s infinite;
        }
        @keyframes pulseRed {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <div class="logo">
            <div class="logo-icon"><i class="fas fa-user-secret" style="font-size:22px"></i></div>
            <div>
                <div class="logo-text">SECUREHAT</div>
                <div style="font-size:0.95rem;color:rgba(255,255,255,0.85);font-weight:600;margin-top:6px;">
                    Private Location Sharing & Chat
                </div>
                <div style="font-size:0.85rem;color:rgba(255,255,255,0.65);margin-top:8px;">
                    <em>Developed by Kurdistan Innovator Team</em>
                </div>
            </div>
        </div>
        <h1>Private Location Sharing & Chat</h1>
        <div class="subtitle muted">Your real name stays local-only unless you choose to share it</div>
    </header>
    <div class="privacy-notice">
        <i class="fas fa-shield-alt" style="color:#4cd137"></i>
        <div><strong>Privacy Notice:</strong> Your real name is stored locally only. If you choose to share it, it will be visible to others in the session. All location data is peer-to-peer and never stored on any server.</div>
    </div>
    <div class="rejoin-notice">
        <i class="fas fa-rotate-left" style="color:#4facfe"></i>
        <div><strong>Rejoin Anytime:</strong> You can leave and rejoin active sessions using the same session code at any time.</div>
    </div>
    <!-- Setup -->
    <div class="card fade-in" id="setup-card">
        <div class="card-title"><i class="fas fa-user"></i> User Setup</div>
        <div class="form-group">
            <label class="form-label">Your Real Name</label>
            <input id="real-name" class="form-control" type="text" placeholder="Type your real name (required)">
            <div class="form-note">This name is stored locally only. You must type it each time you start/resume.</div>
        </div>
        <div class="form-group">
            <label class="form-label">Session Code</label>
            <div class="code-row">
                <input id="session-code" class="code-input" type="password" placeholder="Enter or generate a secure code">
                <button id="gen-code" class="btn small-btn" title="Generate a secure, hard-to-guess code"><i class="fas fa-lock"></i> Generate</button>
                <button id="reveal-code" class="btn btn-outline small-btn" title="Reveal/Hide generated code">Reveal</button>
            </div>
            <div class="code-meta">
                <span id="code-hint">Tip: generate a secure code to reduce guessing. Reveal shows it briefly and enables copy.</span>
                <button id="copy-session-code" class="btn btn-outline small-btn" disabled>Copy</button>
            </div>
        </div>
        <!-- Show real name toggle -->
        <div class="toggle-container">
            <label class="switch">
                <input type="checkbox" id="show-real-name-toggle">
                <span class="slider"></span>
            </label>
            <span>Show my real name to others</span>
        </div>
        <div class="form-note" style="margin-top:8px">Enabling this will share your real name with other participants.</div>
        <div class="btn-container">
            <button id="create-session" class="btn"><i class="fas fa-plus-circle"></i> Create Session</button>
            <button id="open-join" class="btn btn-outline"><i class="fas fa-user-friends"></i> Join Session</button>
        </div>
    </div>
    <!-- Active session card -->
    <div class="card hidden fade-in" id="session-card">
        <div class="card-title"><i class="fas fa-satellite"></i> Active Session</div>
        <div class="session-info">
            <div class="session-status">
                <div class="status-indicator" id="connection-dot"></div>
                <div id="status-text">Ready to connect</div>
            </div>
            <div class="session-timer">
                <i class="fas fa-clock"></i>
                <span id="session-timer">00:00:00</span>
            </div>
            <div class="session-role" id="host-indicator">HOST</div>
        </div>
        <div class="code-container">
            <input id="display-code" class="code-input" readonly placeholder="Session Code">
            <button id="copy-code" class="btn btn-outline" title="Copy code"><i class="fas fa-copy"></i></button>
        </div>
        <div class="btn-container" style="margin-top:16px;grid-template-columns:1fr 1fr 1fr">
            <button id="resume-session" class="btn btn-reconnect"><i class="fas fa-plug"></i> Reconnect</button>
            <button id="share-location" class="btn"><i class="fas fa-location-dot"></i> Share Location</button>
            <button id="stop-session" class="btn btn-stop"><i class="fas fa-power-off"></i> Stop</button>
        </div>
        <!-- SOS Button -->
        <button id="sos-button" class="btn sos-btn hidden"><i class="fas fa-life-ring"></i> SOS Emergency</button>
        <!-- Location management buttons -->
        <div class="btn-container hidden" id="location-controls" style="margin-top:16px;grid-template-columns:1fr 1fr">
            <button id="update-location" class="btn btn-update"><i class="fas fa-sync-alt"></i> Update Location</button>
            <button id="stop-sharing" class="btn btn-unshare"><i class="fas fa-location-slash"></i> Stop Sharing</button>
        </div>
        <div class="form-note" style="margin-top:14px">Note: You can reconnect anytime using the session code.</div>
    </div>
    <!-- Map -->
    <div class="card fade-in">
        <div class="card-title"><i class="fas fa-map-marked-alt"></i> Location Map</div>
        <div class="map-container"><div id="map"></div></div>
        <div id="coordinates-display" class="coordinates-display">Coordinates: Not available</div>
    </div>
    <!-- Connected users + chat -->
    <div class="card fade-in">
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px">
            <div class="card-title"><i class="fas fa-users"></i> Connected Users</div>
            <div class="muted">Chat & messages are anonymized unless you share your name</div>
        </div>
        <div class="user-list" id="user-list">
            <div class="user-card" id="you-card">
                <div class="user-avatar">Y</div>
                <div class="user-info">
                    <div class="user-name" id="your-name-display">You <span class="duration-badge"><i class="fas fa-clock"></i> <span id="your-duration">0s</span></span></div>
                    <div class="location-sharing">
                        <span class="dot"></span>
                        <span><i class="fas fa-location-slash"></i> Location not shared</span>
                    </div>
                    <div style="margin-top:10px"><span class="status-dot"></span> Online</div>
                </div>
            </div>
        </div>
        <div style="margin-top:16px" class="chat-card">
            <div class="chat-header">
                <div class="chat-tabs">
                    <div class="chat-tab active">Text</div>
                    <div class="chat-tab">Voice</div>
                </div>
                <div id="danger-alert" class="danger-status hidden"><i class="fas fa-exclamation-triangle danger-icon"></i> Danger Detected</div>
            </div>
            <div class="chat-messages" id="chat-messages" aria-live="polite">
                <div class="message-system">Welcome to SecureHat! Start by creating or joining a session.</div>
            </div>
            <div class="chat-input-row" style="margin-top:10px">
                <input id="chat-input" class="chat-input" placeholder="Type a message..." />
                <button id="chat-send" class="chat-send"><i class="fas fa-paper-plane"></i> Send</button>
            </div>
            <div class="quick-action-container">
                <button id="quick-safe" class="quick-action-btn safe"><i class="fas fa-check-circle"></i> I'm Safe</button>
                <button id="quick-moving" class="quick-action-btn moving"><i class="fas fa-running"></i> I'm Moving</button>
                <button id="quick-flag-host" class="quick-action-btn host-flag"><i class="fas fa-flag"></i> Host Flagged</button>
            </div>
            <div class="voice-chat-container hidden" id="voice-container">
                <button id="record-voice" class="btn voice-btn"><i class="fas fa-microphone"></i> Record Voice</button>
                <div id="recording-status">Press to record voice message</div>
            </div>
        </div>
    </div>
    <footer>
      <div>SecureHat Â© Privacy First | No Database | Session persists until stopped</div>
      <div style="margin-top:8px;font-size:0.85rem;opacity:0.85;">
        Built and maintained by <strong>Kurdistan Innovator Team</strong>
      </div>
    </footer>
</div>
<!-- Notification -->
<div id="notification" class="notification" role="status" aria-live="polite"><i class="fas fa-info-circle"></i> <span id="notification-message">Ready to start</span></div>
<!-- Join modal -->
<div id="join-modal" aria-hidden="true">
  <div class="join-box">
    <h3 style="margin:0 0 10px"><i class="fas fa-user-friends"></i> Join Session</h3>
    <p class="muted" style="margin:0 0 16px">Enter the session code provided by the host.</p>
    <input id="join-code-input" class="form-control" placeholder="Enter join session code">
    <div style="display:flex;gap:10px;margin-top:16px;justify-content:flex-end">
      <button id="join-cancel" class="btn btn-outline">Cancel</button>
      <button id="join-now" class="btn"><i class="fas fa-sign-in-alt"></i> Join Now</button>
    </div>
  </div>
</div>
<!-- Stop confirmation modal -->
<div id="stop-confirmation" role="dialog" aria-modal="true" aria-labelledby="stop-title">
    <div class="confirmation-box">
        <h3 id="stop-title"><i class="fas fa-exclamation-triangle" style="color:#ffb86b"></i> Confirm Session Stop</h3>
        <p style="margin-top:12px">Are you sure you want to stop the current session? This will end the session for all participants.</p>
        <div class="confirmation-buttons">
            <button id="confirm-stop" class="btn btn-stop"><i class="fas fa-check"></i> Yes, Stop Session</button>
            <button id="cancel-stop" class="btn btn-outline"><i class="fas fa-times"></i> Cancel</button>
        </div>
    </div>
</div>
<!-- SOS Timer Overlay -->
<div id="sos-overlay" class="sos-overlay hidden">
    <div class="sos-timer" id="sos-timer-display">01:30</div>
    <div class="sos-progress">
        <div class="sos-progress-bar" id="sos-progress-bar"></div>
    </div>
    <div class="sos-instructions" id="sos-instructions">Emergency timer active â€” move 1 meter to cancel</div>
    <div class="sos-movement-indicator" id="sos-movement-indicator">No significant movement detected</div>
    <div class="sos-btn-container">
        <button id="sos-cancel-btn" class="btn sos-cancel-btn"><i class="fas fa-walking"></i> Cancel SOS</button>
        <button id="sos-send-btn" class="btn sos-send-btn"><i class="fas fa-life-ring"></i> Send SOS Now</button>
    </div>
</div>
<script>
/* ========= DOM refs ========= */
const realNameInput = document.getElementById('real-name');
const sessionCodeInput = document.getElementById('session-code');
const genCodeBtn = document.getElementById('gen-code');
const revealCodeBtn = document.getElementById('reveal-code');
const copySessionCodeBtn = document.getElementById('copy-session-code');
const showRealNameToggle = document.getElementById('show-real-name-toggle');
const yourNameDisplay = document.getElementById('your-name-display');
const locationControls = document.getElementById('location-controls');
const updateLocationBtn = document.getElementById('update-location');
const stopSharingBtn = document.getElementById('stop-sharing');
const hostIndicator = document.getElementById('host-indicator');
const createSessionBtn = document.getElementById('create-session');
const openJoinBtn = document.getElementById('open-join');
const joinModal = document.getElementById('join-modal');
const joinCodeInput = document.getElementById('join-code-input');
const joinNowBtn = document.getElementById('join-now');
const joinCancelBtn = document.getElementById('join-cancel');
const setupCard = document.getElementById('setup-card');
const sessionCard = document.getElementById('session-card');
const displayCodeInput = document.getElementById('display-code');
const copyCodeBtn = document.getElementById('copy-code');
const shareLocationBtn = document.getElementById('share-location');
const stopSessionBtn = document.getElementById('stop-session');
const resumeSessionBtn = document.getElementById('resume-session');
const statusText = document.getElementById('status-text');
const connectionDot = document.getElementById('connection-dot');
const notification = document.getElementById('notification');
const notificationMessage = document.getElementById('notification-message');
const userList = document.getElementById('user-list');
const stopConfirmation = document.getElementById('stop-confirmation');
const confirmStopBtn = document.getElementById('confirm-stop');
const cancelStopBtn = document.getElementById('cancel-stop');
const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
const codeHint = document.getElementById('code-hint');
const sessionTimer = document.getElementById('session-timer');
const yourDuration = document.getElementById('your-duration');
const sosButton = document.getElementById('sos-button');
const recordVoiceBtn = document.getElementById('record-voice');
const voiceContainer = document.getElementById('voice-container');
const recordingStatus = document.getElementById('recording-status');
const dangerAlert = document.getElementById('danger-alert');
const coordinatesDisplay = document.getElementById('coordinates-display');
const sosOverlay = document.getElementById('sos-overlay');
const sosTimerDisplay = document.getElementById('sos-timer-display');
const sosProgressBar = document.getElementById('sos-progress-bar');
const sosInstructions = document.getElementById('sos-instructions');
const sosMovementIndicator = document.getElementById('sos-movement-indicator');
const sosCancelBtn = document.getElementById('sos-cancel-btn');
const sosSendBtn = document.getElementById('sos-send-btn');
const quickSafeBtn = document.getElementById('quick-safe');
const quickMovingBtn = document.getElementById('quick-moving');
const quickFlagHostBtn = document.getElementById('quick-flag-host');

/* ========= State ========= */
let peer = null;
let conn = null;
let myAlias = '';
let myMarker = null;
let peerMarker = null;
let notificationTimeout = null;
let sessionRoleCached = null;
let locationShared = false;
let isHost = false;
let peerAlias = null;
let codeRevealed = false;
let autoHideTimeout = null;
let sessionStartTime = null;
let timerInterval = null;
let peerDurationInterval = null;
let peerDuration = 0;
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;
let dangerCheckInterval = null;
let lastPosition = null;
let lastPositionTime = null;
let dangerMarkers = [];
let voiceAlertInterval = null;
let dangerStatus = {};

// SOS Timer State
let sosTimer = null;
let sosTimerInterval = null;
let sosStartTime = null;
let sosOriginalPosition = null;
let movementDetected = false;
let accelerometerData = [];
let deviceMotionSupported = false;
let watchPositionId = null;

/* ========= Map init ========= */
const map = L.map('map', { 
    attributionControl: false,
    center: [34.5, 45.5], // Kurdistan approximate center
    zoom: 7
});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// Add danger icon
const dangerIcon = L.icon({
    iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBmaWxsPSIjZTg0MTE4Ij48cGF0aCBkPSJNMjU2IDhDMTE5LjA0MyA4IDggMTE5LjA4MyA4IDI1NmMwIDEzNi45OTcgMTExLjA0MyAyNDggMjQ4IDI0OHMyNDgtMTExLjAwMyAyNDgtMjQ4QzUwNCAxMTkuMDgzIDM5Mi45NTcgOCAyNTYgOHptMCA0MjRjLTEzLjI1NSAwLTI0LTEwLjc0NS0yNC0yNHMxMC43NDUtMjQgMjQtMjQgMjQgMTAuNzQ1IDI0IDI0LTEwLjc0NSAyNC0yNCAyNHptMC0zNjhjLTE3LjY3MyAwLTMyIDE0LjMyNy0zMiAzMnYxNzZjMCAxNy42NzMgMTQuMzI3IDMyIDMyIDMyczMyLTE0LjMyNyAzMi0zMlY5NmMwLTE3LjY3My0xNC4zMjctMzItMzItMzJ6Ii8+PC9zdmc+',
    iconSize: [25, 25],
    iconAnchor: [12, 25],
    popupAnchor: [0, -25]
});

// Original position marker icon
const originalPositionIcon = L.icon({
    iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBmaWxsPSIjZTg0MTE4Ij48cGF0aCBkPSJNMjU2IDhDMTE5LjA0MyA4IDggMTE5LjA4MyA4IDI1NmMwIDEzNi45OTcgMTExLjA0MyAyNDggMjQ4IDI0OHMyNDgtMTExLjAwMyAyNDgtMjQ4QzUwNCAxMTkuMDgzIDM5Mi45NTcgOCAyNTYgOHptMCA0MjRjLTEzLjI1NSAwLTI0LTEwLjc0NS0yNC0yNHMxMC43NDUtMjQgMjQtMjQgMjQgMTAuNzQ1IDI0IDI0LTEwLjc0NSAyNC0yNCAyNHptMC0zNjhjLTE3LjY3MyAwLTMyIDE0LjMyNy0zMiAzMnYxNzZjMCAxNy42NzMgMTQuMzI3IDMyIDMyIDMyczMyLTE0LjMyNyAzMi0zMlY5NmMwLTE3LjY3My0xNC4zMjctMzItMzItMzJ6Ii8+PC9zdmc+',
    iconSize: [20, 20],
    iconAnchor: [10, 20],
    popupAnchor: [0, -20]
});

// Current position marker icon
const currentPositionIcon = L.icon({
    iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBmaWxsPSIjNGNkMTM3Ij48cGF0aCBkPSJNMjU2IDhDMTE5LjA0MyA4IDggMTE5LjA4MyA4IDI1NmMwIDEzNi45OTcgMTExLjA0MyAyNDggMjQ4IDI0OHMyNDgtMTExLjAwMyAyNDgtMjQ4QzUwNCAxMTkuMDgzIDM5Mi45NTcgOCAyNTYgOHptMCA0MjRjLTEzLjI1NSAwLTI0LTEwLjc0NS0yNC0yNHMxMC43NDUtMjQgMjQtMjQgMjQgMTAuNzQ1IDI0IDI0LTEwLjc0NSAyNC0yNCAyNHptMC0zNjhjLTE3LjY3MyAwLTMyIDE0LjMyNy0zMiAzMnYxNzZjMCAxNy42NzMgMTQuMzI3IDMyIDMyIDMyczMyLTE0LjMyNyAzMi0zMlY5NmMwLTE3LjY3My0xNC4zMjctMzItMzItMzJ6Ii8+PC9zdmc+',
    iconSize: [20, 20],
    iconAnchor: [10, 20],
    popupAnchor: [0, -20]
});

/* ========= Helpers ========= */
function generateAnonAlias(){ 
    const adjectives = ["Swift", "Clever", "Brave", "Wise", "Gentle", "Fierce", "Noble", "Silent", "Bright", "Calm"];
    const nouns = ["Fox", "Eagle", "Lion", "Wolf", "Hawk", "Bear", "Deer", "Owl", "Horse", "Falcon"];
    const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    return `${adj} ${noun}`;
}

function showNotification(msg, isError=false, duration=3000){
    if(notificationTimeout){ clearTimeout(notificationTimeout); notificationTimeout=null; }
    notificationMessage.textContent = msg;
    notification.classList.add('show');
    if(isError) notification.classList.add('error'); else notification.classList.remove('error');
    notificationTimeout = setTimeout(()=>{ notification.classList.remove('show'); notification.classList.remove('error'); }, duration);
    // Also show browser notification if allowed
    if ("Notification" in window && Notification.permission === "granted") {
        new Notification("SecureHat Alert", {
            body: msg,
            icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBmaWxsPSIjZmY3ZTVmIj48cGF0aCBkPSJNMjU2IDhDMTE5LjA0MyA4IDggMTE5LjA4MyA4IDI1NmMwIDEzNi45OTcgMTExLjA0MyAyNDggMjQ4IDI0OHMyNDgtMTExLjAwMyAyNDgtMjQ4QzUwNCAxMTkuMDgzIDM5Mi45NTcgOCAyNTYgOHptMCA0MjRjLTEzLjI1NSAwLTI0LTEwLjc0NS0yNC0yNHMxMC43NDUtMjQgMjQtMjQgMjQgMTAuNzQ1IDI0IDI0LTEwLjc0NSAyNC0yNCAyNHptMC0zNjhjLTE3LjY3MyAwLTMyIDE0LjMyNy0zMiAzMnYxNzZjMCAxNy42NzMgMTQuMzI3IDMyIDMyIDMyczMyLTE0LjMyNyAzMi0zMlY5NmMwLTE3LjY3My0xNC4zMjctMzItMzItMzJ6Ii8+PC9zdmc+"
        });
    }
}

// Request notification permission
function requestNotificationPermission() {
    if ("Notification" in window) {
        Notification.requestPermission();
    }
}

function updateStatus(text, connected=false){
    statusText.textContent = text;
    connectionDot.className = connected ? 'status-indicator connected' : 'status-indicator';
}

function updateSessionTimer() {
    if (!sessionStartTime) return;
    const elapsed = Date.now() - sessionStartTime;
    const seconds = Math.floor((elapsed / 1000) % 60);
    const minutes = Math.floor((elapsed / (1000 * 60)) % 60);
    const hours = Math.floor(elapsed / (1000 * 60 * 60));
    const formattedTime = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    sessionTimer.textContent = formattedTime;
    // Update personal duration
    yourDuration.textContent = formatDuration(elapsed);
}

function formatDuration(milliseconds) {
    const seconds = Math.floor((milliseconds / 1000) % 60);
    const minutes = Math.floor((milliseconds / (1000 * 60)) % 60);
    const hours = Math.floor(milliseconds / (1000 * 60 * 60));
    if (hours > 0) {
        return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${seconds}s`;
    } else {
        return `${seconds}s`;
    }
}

function safeSend(payload){
    if(!conn || conn.open === false) return;
    try { conn.send(payload); } catch(e){ console.error('send failed', e); showNotification('Send failed', true); }
}

function destroyExistingPeer(){
    if(conn){ try{ conn.close(); }catch(e){} conn=null; }
    if(peer){ try{ peer.destroy(); }catch(e){} peer=null; }
}

async function copyToClipboard(text){
    try {
        if(navigator.clipboard && window.isSecureContext){
            await navigator.clipboard.writeText(text);
        } else {
            const ta = document.createElement('textarea'); ta.value=text;
            ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta);
            ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
        }
        showNotification('Code copied to clipboard');
    } catch(e){ console.error(e); showNotification('Copy failed', true); }
}

function generateSecureCode(length = 8) {
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const arr = new Uint8Array(length);
    window.crypto.getRandomValues(arr);
    let s = '';
    for (let i = 0; i < arr.length; i++) {
        s += alphabet[arr[i] % alphabet.length];
    }
    return s;
}

genCodeBtn.addEventListener('click', () => {
    const code = generateSecureCode(8);
    sessionCodeInput.value = code;
    maskCodeDisplay();
    showNotification('Secure code generated. Click Reveal to view and copy.');
});

function maskCodeDisplay() {
    codeRevealed = false;
    sessionCodeInput.type = 'password';
    sessionCodeInput.style.letterSpacing = 'normal';
    revealCodeBtn.textContent = 'Reveal';
    copySessionCodeBtn.disabled = true;
    if (autoHideTimeout) { clearTimeout(autoHideTimeout); autoHideTimeout = null; }
}

function revealCodeTemporarily() {
    if (!sessionCodeInput.value) {
        showNotification('No code to reveal', true);
        return;
    }
    codeRevealed = true;
    sessionCodeInput.type = 'text';
    sessionCodeInput.style.letterSpacing = '3px';
    revealCodeBtn.textContent = 'Hide';
    copySessionCodeBtn.disabled = false;
    if (autoHideTimeout) clearTimeout(autoHideTimeout);
    autoHideTimeout = setTimeout(() => {
        maskCodeDisplay();
        showNotification('Code auto-hidden for security');
    }, 20000);
}

revealCodeBtn.addEventListener('click', () => {
    if (codeRevealed) {
        maskCodeDisplay();
    } else {
        revealCodeTemporarily();
    }
});

copySessionCodeBtn.addEventListener('click', () => {
    if (!sessionCodeInput.value) { showNotification('No code to copy', true); return; }
    if (!codeRevealed) { showNotification('Reveal the code first to enable copying', true); return; }
    copyToClipboard(sessionCodeInput.value);
});

/* ========= Voice Recording ========= */
function setupVoiceRecording() {
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        recordVoiceBtn.addEventListener('click', toggleRecording);
    } else {
        voiceContainer.classList.add('hidden');
        showNotification('Voice recording not supported on this device', true);
    }
}

function toggleRecording() {
    if (isRecording) {
        stopRecording();
    } else {
        startRecording();
    }
}

function startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            mediaRecorder.addEventListener('dataavailable', event => {
                audioChunks.push(event.data);
            });
            mediaRecorder.addEventListener('stop', () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                sendVoiceMessage(audioBlob);
                // Stop all audio tracks
                stream.getTracks().forEach(track => track.stop());
            });
            mediaRecorder.start();
            isRecording = true;
            recordVoiceBtn.classList.add('recording');
            recordingStatus.textContent = 'Recording... Click to stop';
        })
        .catch(error => {
            console.error('Error accessing microphone:', error);
            showNotification('Could not access microphone', true);
        });
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        isRecording = false;
        recordVoiceBtn.classList.remove('recording');
        recordingStatus.textContent = 'Press to record voice message';
    }
}

function sendVoiceMessage(audioBlob) {
    const reader = new FileReader();
    reader.readAsDataURL(audioBlob);
    reader.onloadend = function() {
        const base64Audio = reader.result;
        // Display the voice message locally
        appendMessage('Voice message', true, false, null, base64Audio);
        // Send to peer
        if (conn && conn.open) {
            safeSend({ 
                type: 'voice', 
                audio: base64Audio,
                clientAlias: myAlias,
                timestamp: new Date().toISOString()
            });
        }
    };
}

/* ========= Movement Detection System ========= */
function initializeMovementDetection() {
    // Check if DeviceMotion is supported
    if (window.DeviceMotionEvent) {
        deviceMotionSupported = true;
        window.addEventListener('devicemotion', handleDeviceMotion);
    }
    
    // Check if we have permission for geolocation
    if (!navigator.geolocation) {
        showNotification('Geolocation not supported on this device', true);
        return;
    }
}

function handleDeviceMotion(event) {
    if (!event.acceleration) return;
    
    const acceleration = event.acceleration;
    const timestamp = Date.now();
    
    // Store accelerometer data
    accelerometerData.push({
        x: acceleration.x,
        y: acceleration.y,
        z: acceleration.z,
        timestamp: timestamp
    });
    
    // Keep only last 10 seconds of data
    const cutoffTime = timestamp - 10000;
    accelerometerData = accelerometerData.filter(data => data.timestamp > cutoffTime);
}

function detectMovement(currentPosition) {
    if (!sosOriginalPosition || !currentPosition) return false;
    
    // Calculate distance from original position
    const distance = calculateDistance(
        sosOriginalPosition.latitude, 
        sosOriginalPosition.longitude,
        currentPosition.latitude, 
        currentPosition.longitude
    );
    
    // If distance >= 1 meter, movement is detected
    if (distance >= 1.0) {
        // Additional check: if we have accelerometer data, verify it shows movement
        if (deviceMotionSupported && accelerometerData.length > 0) {
            const movementScore = calculateMovementScore();
            if (movementScore > 0.5) { // Threshold for significant movement
                return true;
            }
        } else {
            // No accelerometer data, rely on GPS only
            return true;
        }
    }
    
    return false;
}

function calculateMovementScore() {
    if (accelerometerData.length < 5) return 0;
    
    let maxAcceleration = 0;
    let totalMovement = 0;
    
    for (let i = 1; i < accelerometerData.length; i++) {
        const prev = accelerometerData[i-1];
        const curr = accelerometerData[i];
        
        // Calculate change in acceleration
        const delta = Math.sqrt(
            Math.pow(curr.x - prev.x, 2) + 
            Math.pow(curr.y - prev.y, 2) + 
            Math.pow(curr.z - prev.z, 2)
        );
        
        totalMovement += delta;
        if (delta > maxAcceleration) {
            maxAcceleration = delta;
        }
    }
    
    // Simple scoring: if we have significant acceleration changes, it's likely movement
    // This is a simplified approach - in production, you'd want more sophisticated step detection
    return Math.min(maxAcceleration / 2, 1); // Normalize to 0-1 range
}

/* ========= SOS Timer System ========= */
function startSOSTimer() {
    // Record start time and original position
    sosStartTime = Date.now();
    sosOriginalPosition = { ...lastPosition };
    movementDetected = false;
    
    // Show SOS overlay
    sosOverlay.classList.remove('hidden');
    sosTimerDisplay.textContent = '01:30';
    sosProgressBar.style.width = '100%';
    sosInstructions.textContent = 'Emergency timer active â€” move 1 meter to cancel';
    sosMovementIndicator.textContent = 'No significant movement detected';
    
    // Start timer
    let timeLeft = 90; // 90 seconds
    sosTimerInterval = setInterval(() => {
        timeLeft--;
        
        // Update display
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        sosTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update progress bar
        const progress = (timeLeft / 90) * 100;
        sosProgressBar.style.width = `${progress}%`;
        
        // Low time warning (last 10 seconds)
        if (timeLeft <= 10) {
            sosTimerDisplay.classList.add('low-time');
            // Vibrate if supported
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200]);
            }
        }
        
        // Check for movement
        if (lastPosition && detectMovement(lastPosition)) {
            movementDetected = true;
            sosMovementIndicator.textContent = 'Movement detected: SOS canceled';
            cancelSOSTimer();
            showNotification('Movement detected. SOS canceled.');
            return;
        }
        
        // Timer expired
        if (timeLeft <= 0) {
            clearInterval(sosTimerInterval);
            sosTimerInterval = null;
            
            // For hosts, don't send automatic SOS
            if (isHost) {
                sosInstructions.textContent = 'Host is exempt from automatic SOS â€” please send manual SOS or confirm status.';
                sosSendBtn.textContent = 'Send Manual SOS';
                sosSendBtn.classList.remove('hidden');
                sosCancelBtn.textContent = 'Confirm Status';
                
                // Log the event
                console.log(`[SOS Timer] Host timer expired at ${new Date().toISOString()}. No automatic SOS sent.`);
                showNotification('Host timer expired. No automatic SOS sent.', false, 5000);
            } else {
                // Send automatic SOS for non-hosts
                sendAutomaticSOS();
            }
        }
    }, 1000);
    
    // Start watching position for more accurate updates during SOS
    if (navigator.geolocation && watchPositionId === null) {
        watchPositionId = navigator.geolocation.watchPosition(
            (position) => {
                const latitude = position.coords.latitude;
                const longitude = position.coords.longitude;
                lastPosition = { latitude, longitude };
                lastPositionTime = Date.now();
                
                // Update movement indicator
                if (sosOriginalPosition) {
                    const distance = calculateDistance(
                        sosOriginalPosition.latitude, 
                        sosOriginalPosition.longitude,
                        latitude, 
                        longitude
                    );
                    sosMovementIndicator.textContent = `Movement detected: ${distance.toFixed(2)} meters`;
                }
                
                // Update map with original and current position
                updateSOSMarkers();
            },
            (error) => {
                console.error('Geolocation error during SOS:', error);
                sosMovementIndicator.textContent = 'Location error: Movement detection may be less precise';
            },
            { 
                enableHighAccuracy: true, 
                maximumAge: 5000, 
                timeout: 10000 
            }
        );
    }
}

function updateSOSMarkers() {
    // Remove existing SOS markers
    if (window.sosOriginalMarker) {
        map.removeLayer(window.sosOriginalMarker);
    }
    if (window.sosCurrentMarker) {
        map.removeLayer(window.sosCurrentMarker);
    }
    
    // Add original position marker
    if (sosOriginalPosition) {
        window.sosOriginalMarker = L.marker(
            [sosOriginalPosition.latitude, sosOriginalPosition.longitude], 
            { icon: originalPositionIcon }
        ).addTo(map).bindPopup('Original Position (SOS Timer Start)');
    }
    
    // Add current position marker
    if (lastPosition) {
        window.sosCurrentMarker = L.marker(
            [lastPosition.latitude, lastPosition.longitude], 
            { icon: currentPositionIcon }
        ).addTo(map).bindPopup('Current Position');
    }
}

function cancelSOSTimer() {
    if (sosTimerInterval) {
        clearInterval(sosTimerInterval);
        sosTimerInterval = null;
    }
    
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }
    
    // Remove SOS markers
    if (window.sosOriginalMarker) {
        map.removeLayer(window.sosOriginalMarker);
        window.sosOriginalMarker = null;
    }
    if (window.sosCurrentMarker) {
        map.removeLayer(window.sosCurrentMarker);
        window.sosCurrentMarker = null;
    }
    
    // Hide overlay
    sosOverlay.classList.add('hidden');
    
    // Reset state
    sosStartTime = null;
    sosOriginalPosition = null;
    movementDetected = false;
}

function sendAutomaticSOS() {
    // Send SOS alert to peers
    if (conn && conn.open) {
        safeSend({
            type: 'sos',
            clientAlias: myAlias,
            position: lastPosition,
            timestamp: Date.now(),
            automatic: true,
            timerExpired: true
        });
    }
    
    // Mark user as in danger
    setDangerStatus(myAlias, true);
    
    // Play immediate alert
    playDangerAlert();
    
    // Hide overlay
    sosOverlay.classList.add('hidden');
    
    // Log the event
    console.log(`[SOS Timer] Automatic SOS sent at ${new Date().toISOString()} for user ${myAlias}`);
    
    // Show notification
    showNotification('No sufficient movement detected. SOS sent at ' + new Date().toLocaleTimeString(), true);
    
    // Reset state
    sosStartTime = null;
    sosOriginalPosition = null;
    movementDetected = false;
    
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }
    
    // Remove SOS markers
    if (window.sosOriginalMarker) {
        map.removeLayer(window.sosOriginalMarker);
        window.sosOriginalMarker = null;
    }
    if (window.sosCurrentMarker) {
        map.removeLayer(window.sosCurrentMarker);
        window.sosCurrentMarker = null;
    }
}

// SOS Button Event Listeners
sosButton.addEventListener('click', () => {
    if (!conn || !conn.open) {
        showNotification('Not connected to any peers', true);
        return;
    }
    
    // Start the SOS timer
    startSOSTimer();
});

sosCancelBtn.addEventListener('click', () => {
    cancelSOSTimer();
    showNotification('SOS timer canceled');
});

sosSendBtn.addEventListener('click', () => {
    // Send manual SOS (bypassing timer)
    if (conn && conn.open) {
        safeSend({
            type: 'sos',
            clientAlias: myAlias,
            position: lastPosition,
            timestamp: Date.now(),
            automatic: false,
            manual: true
        });
    }
    
    // Mark user as in danger
    setDangerStatus(myAlias, true);
    
    // Play immediate alert
    playDangerAlert();
    
    // Hide overlay
    sosOverlay.classList.add('hidden');
    
    // Show notification
    showNotification('Manual SOS sent to all team members', false);
    
    // Reset state
    sosStartTime = null;
    sosOriginalPosition = null;
    movementDetected = false;
    
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }
    
    // Remove SOS markers
    if (window.sosOriginalMarker) {
        map.removeLayer(window.sosOriginalMarker);
        window.sosOriginalMarker = null;
    }
    if (window.sosCurrentMarker) {
        map.removeLayer(window.sosCurrentMarker);
        window.sosCurrentMarker = null;
    }
});

/* ========= Danger Monitoring System ========= */
function startDangerMonitoring() {
    if (dangerCheckInterval) clearInterval(dangerCheckInterval);
    dangerCheckInterval = setInterval(() => {
        checkForDanger();
    }, 10000); // Check every 10 seconds
}

function checkForDanger() {
    if (!lastPosition || !lastPositionTime) return;
    const currentTime = Date.now();
    const timeDiff = (currentTime - lastPositionTime) / 1000; // in seconds
    
    // If user hasn't moved for 90 seconds, mark as in danger
    if (timeDiff > 90) {
        setDangerStatus(myAlias, true);
        // Send danger alert to peers
        if (conn && conn.open) {
            safeSend({
                type: 'danger',
                clientAlias: myAlias,
                inDanger: true,
                position: lastPosition,
                timestamp: currentTime
            });
        }
        // Play voice alert every 10 seconds
        if (!voiceAlertInterval) {
            playDangerAlert();
            voiceAlertInterval = setInterval(playDangerAlert, 10000);
        }
    }
}

function playDangerAlert() {
    const alertMessage = `${myAlias} is in danger! Please check their location.`;
    showNotification(alertMessage, true);
    // Use speech synthesis if available
    if ('speechSynthesis' in window) {
        const speech = new SpeechSynthesisUtterance(alertMessage);
        window.speechSynthesis.speak(speech);
    }
}

function setDangerStatus(alias, inDanger) {
    dangerStatus[alias] = inDanger;
    
    // Update UI
    const userCards = document.querySelectorAll('.user-card');
    userCards.forEach(card => {
        const nameElement = card.querySelector('.user-name');
        if (nameElement && nameElement.textContent.includes(alias)) {
            if (inDanger) {
                card.classList.add('danger');
                card.classList.add('danger-animation');
                
                // Add danger icon and update badge
                let badge = card.querySelector('.host-in-danger');
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'host-in-danger';
                    if (isHost && alias === myAlias) {
                        badge.textContent = 'Host â€” In Danger (manual SOS required)';
                    } else if (alias === myAlias && isHost) {
                        badge.textContent = 'Host â€” In Danger (manual SOS required)';
                    } else {
                        badge.textContent = 'In Danger';
                    }
                    nameElement.appendChild(badge);
                }
                
                // Show danger alert in chat
                if (alias !== myAlias) {
                    dangerAlert.classList.remove('hidden');
                    appendMessage(`${alias} is in danger! Please check their location.`, false, true);
                }
            } else {
                card.classList.remove('danger');
                card.classList.remove('danger-animation');
                
                // Remove danger badge
                const badge = card.querySelector('.host-in-danger');
                if (badge) badge.remove();
                
                if (alias !== myAlias && Object.values(dangerStatus).every(status => !status)) {
                    dangerAlert.classList.add('hidden');
                }
            }
        }
    });
    
    // Clear danger markers if no longer in danger
    if (!inDanger) {
        clearDangerMarkers(alias);
    }
}

function addDangerMarker(position, alias) {
    // Remove existing danger marker for this user
    clearDangerMarkers(alias);
    const marker = L.marker([position.latitude, position.longitude], { icon: dangerIcon })
        .addTo(map)
        .bindPopup(`<b>DANGER: ${alias}</b><br>User may be in danger`);
    dangerMarkers.push({ alias, marker });
    
    // Flash the marker
    let visible = true;
    const flashInterval = setInterval(() => {
        if (visible) {
            marker.setOpacity(0.3);
        } else {
            marker.setOpacity(1);
        }
        visible = !visible;
    }, 1000);
    
    // Store the interval to clear it later
    marker.flashInterval = flashInterval;
}

function clearDangerMarkers(alias) {
    for (let i = dangerMarkers.length - 1; i >= 0; i--) {
        if (dangerMarkers[i].alias === alias) {
            clearInterval(dangerMarkers[i].marker.flashInterval);
            map.removeLayer(dangerMarkers[i].marker);
            dangerMarkers.splice(i, 1);
        }
    }
}

/* ========= Quick Action Buttons ========= */
quickSafeBtn.addEventListener('click', () => {
    appendMessage('I\'m safe!', true);
    if (conn && conn.open) {
        safeSend({ 
            type: 'chat', 
            text: 'I\'m safe!', 
            clientAlias: myAlias,
            quickAction: 'safe'
        });
    }
    
    // If user was in danger, clear the status
    if (dangerStatus[myAlias]) {
        setDangerStatus(myAlias, false);
        if (voiceAlertInterval) {
            clearInterval(voiceAlertInterval);
            voiceAlertInterval = null;
        }
        if (conn && conn.open) {
            safeSend({
                type: 'danger',
                clientAlias: myAlias,
                inDanger: false,
                timestamp: Date.now()
            });
        }
    }
});

quickMovingBtn.addEventListener('click', () => {
    appendMessage('I\'m moving to safety!', true);
    if (conn && conn.open) {
        safeSend({ 
            type: 'chat', 
            text: 'I\'m moving to safety!', 
            clientAlias: myAlias,
            quickAction: 'moving'
        });
    }
});

quickFlagHostBtn.addEventListener('click', () => {
    // Check if there's a host to flag
    const hostCard = document.querySelector('.user-card .host-exempt-badge');
    if (!hostCard) {
        showNotification('No host found to flag', true);
        return;
    }
    
    // Get host alias from the card
    const hostNameElement = hostCard.parentElement.querySelector('.user-name');
    const hostAlias = hostNameElement.textContent.replace(' Host (exempt from auto-SOS)', '').trim();
    
    // Send flag message
    appendMessage(`Host ${hostAlias} flagged as in danger â€” manual response required`, true);
    if (conn && conn.open) {
        safeSend({ 
            type: 'chat', 
            text: `Host ${hostAlias} flagged as in danger â€” manual response required`, 
            clientAlias: myAlias,
            quickAction: 'flag-host',
            targetHost: hostAlias
        });
        
        // Also send a danger alert for the host
        safeSend({
            type: 'danger',
            clientAlias: hostAlias,
            inDanger: true,
            position: lastPosition,
            timestamp: Date.now(),
            flaggedBy: myAlias
        });
    }
    
    // Update UI to show host as in danger
    setDangerStatus(hostAlias, true);
    showNotification(`Host ${hostAlias} flagged in danger â€” manual response required`, true);
});

/* ========= Join modal behavior ========= */
openJoinBtn.addEventListener('click', () => {
    joinModal.classList.add('show');
    joinModal.setAttribute('aria-hidden', 'false');
    joinCodeInput.value = '';
    setTimeout(()=> joinCodeInput.focus(), 60);
});

joinCancelBtn.addEventListener('click', () => {
    joinModal.classList.remove('show');
    joinModal.setAttribute('aria-hidden', 'true');
});

joinNowBtn.addEventListener('click', () => {
    const code = (joinCodeInput.value || '').trim();
    if (!code || code.length < 4) {
        showNotification('Enter a valid join code (min 4 chars)', true);
        return;
    }
    sessionCodeInput.value = code;
    maskCodeDisplay();
    joinModal.classList.remove('show');
    joinModal.setAttribute('aria-hidden', 'true');
    if (!realNameInput.value.trim()) {
        showNotification('Type your real name before joining.', true);
        setupCard.classList.remove('hidden');
        sessionCard.classList.add('hidden');
        return;
    }
    startSession(false);
});

joinModal.addEventListener('click', (e) => {
    if (e.target === joinModal) {
        joinModal.classList.remove('show');
        joinModal.setAttribute('aria-hidden', 'true');
    }
});

/* ========= Create / Join ========= */
function startSession(host){
    isHost = host;
    const code = (sessionCodeInput.value || '').trim();
    const realName = (realNameInput.value || '').trim();
    if(!realName){
        showNotification('Type your real name to proceed', true); return;
    }
    if(code.length < 4){ showNotification('Enter a valid code (min 4 chars)', true); return; }
    if(localStorage.getItem('session_active') === 'true' && host){
        showNotification('A session is already active locally. Stop it first or Resume.', true);
        return;
    }
    localStorage.setItem('local_real_name', realName);
    localStorage.setItem('session_code', code);
    localStorage.setItem('session_active', 'true');
    localStorage.setItem('session_role', host ? 'host' : 'joiner');
    sessionRoleCached = host ? 'host' : 'joiner';
    
    // Set alias based on user preference
    const showRealName = showRealNameToggle.checked;
    if(showRealName) {
        myAlias = realName;
    } else {
        myAlias = generateAnonAlias();
    }
    
    setupCard.classList.add('hidden');
    sessionCard.classList.remove('hidden');
    displayCodeInput.value = code;
    updateStatus('Connecting...', false);
    locationControls.classList.add('hidden');
    locationShared = false;
    sosButton.classList.remove('hidden');
    
    if(isHost) {
        hostIndicator.classList.remove('hidden');
        // Add host badge to user card
        const yourNameDisplay = document.getElementById('your-name-display');
        let hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
        if (!hostBadge) {
            hostBadge = document.createElement('span');
            hostBadge.className = 'host-exempt-badge';
            hostBadge.textContent = 'Host (exempt from auto-SOS)';
            yourNameDisplay.appendChild(hostBadge);
        }
    } else {
        hostIndicator.classList.add('hidden');
        // Remove host badge if present
        const yourNameDisplay = document.getElementById('your-name-display');
        const hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
        if (hostBadge) hostBadge.remove();
    }
    
    // Show voice chat UI
    voiceContainer.classList.remove('hidden');
    
    // Clear chat and add welcome message
    chatMessages.innerHTML = '';
    if(isHost) {
        appendMessage("You created a session. Share the code with others to join.", false, true);
    } else {
        appendMessage("Joining session...", false, true);
    }
    
    // Start session timer
    sessionStartTime = Date.now();
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(updateSessionTimer, 1000);
    updateSessionTimer();
    
    // Start danger monitoring
    startDangerMonitoring();
    
    // Initialize movement detection
    initializeMovementDetection();
    
    destroyExistingPeer();
    setControlsDisabled(true);
    reconnectAttempts = 0;
    const MAX_JOIN_ATTEMPTS = 8;
    const JOIN_INTERVAL_MS = 1500;
    
    try {
        peer = host ? new Peer(code) : new Peer();
    } catch(e){ 
        console.error('Peer create failed', e); 
        showNotification('Peer init failed', true); 
        updateStatus('Error', false); 
        return; 
    }
    
    peer.on('open', (id) => {
        if(!host){
            function tryConnect(){
                reconnectAttempts++;
                try {
                    conn = peer.connect(code, { reliable: true, serialization: 'json' });
                } catch(err){
                    console.warn('connect exception', err);
                    conn = null;
                }
                if(conn){
                    conn.on('open', () => {
                        updateStatus('Connected to host', true);
                        showNotification('Connected to host');
                        safeSend({ type:'alias', alias: myAlias });
                        appendMessage(`You joined the session as ${myAlias}`, false, true);
                        reconnectAttempts = 0;
                    });
                    conn.on('error', (err) => { 
                        console.error('conn error', err); 
                        showNotification('Connection error: ' + err.message, true); 
                    });
                    setupDataChannel(conn);
                } else {
                    if(reconnectAttempts < MAX_JOIN_ATTEMPTS){
                        updateStatus(`Reconnecting... (${reconnectAttempts}/${MAX_JOIN_ATTEMPTS})`, false);
                        setTimeout(tryConnect, JOIN_INTERVAL_MS);
                    } else {
                        showNotification('Unable to connect to host (no host found).', true);
                        updateStatus('Unable to connect', false);
                        setControlsDisabled(false);
                    }
                }
            }
            tryConnect();
        } else {
            updateStatus('Hosting â€” waiting for peers', true);
            showNotification('Hosting session â€” share the code (reveal briefly to copy).');
            setControlsDisabled(false);
        }
    });
    
    peer.on('connection', (connection) => {
        conn = connection;
        setupDataChannel(conn);
        updateStatus('Peer connected', true);
        showNotification('Peer connected');
        safeSend({ type:'alias', alias: myAlias });
        appendMessage(`Peer ${myAlias} joined the session`, false, true);
    });
    
    peer.on('disconnected', () => { 
        updateStatus('Disconnected', false); 
        showNotification('Network disconnected', true); 
        setControlsDisabled(false); 
    });
    
    peer.on('close', () => { 
        updateStatus('Closed', false); 
        setControlsDisabled(false); 
    });
    
    peer.on('error', (err) => { 
        console.error('peer error', err); 
        showNotification('Peer error: ' + String(err), true); 
        updateStatus('Error', false); 
        setControlsDisabled(false); 
    });
}

function setupDataChannel(connection){
    if(!connection) return;
    connection.on('data', (data) => {
        if(data.type === 'alias') {
            peerAlias = data.alias;
            updatePeerAlias(data);
            appendMessage(`${data.alias} joined the session`, false, true);
        }
        else if(data.type === 'location') updatePeerLocation(data);
        else if(data.type === 'chat') {
            const txt = (data && data.text) ? String(data.text) : '';
            appendMessage(`${data.clientAlias}: ${txt}`, false);
            
            // Handle quick actions
            if (data.quickAction === 'safe' && dangerStatus[data.clientAlias]) {
                setDangerStatus(data.clientAlias, false);
                clearDangerMarkers(data.clientAlias);
            }
            else if (data.quickAction === 'flag-host' && data.targetHost) {
                setDangerStatus(data.targetHost, true);
                // Add host in danger badge
                const userCards = document.querySelectorAll('.user-card');
                userCards.forEach(card => {
                    const nameElement = card.querySelector('.user-name');
                    if (nameElement && nameElement.textContent.includes(data.targetHost)) {
                        let badge = card.querySelector('.host-in-danger');
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.className = 'host-in-danger';
                            badge.textContent = 'Host â€” In Danger (manual SOS required)';
                            nameElement.appendChild(badge);
                        }
                    }
                });
                showNotification(`${data.targetHost} flagged in danger â€” manual response required`, true);
            }
        }
        else if(data.type === 'host-migration') {
            isHost = true;
            hostIndicator.classList.remove('hidden');
            // Add host badge
            const yourNameDisplay = document.getElementById('your-name-display');
            let hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
            if (!hostBadge) {
                hostBadge = document.createElement('span');
                hostBadge.className = 'host-exempt-badge';
                hostBadge.textContent = 'Host (exempt from auto-SOS)';
                yourNameDisplay.appendChild(hostBadge);
            }
            appendMessage(`You are now the host of the session`, false, true);
            showNotification('You are now the host');
        }
        else if(data.type === 'rejoin') {
            appendMessage(`${data.alias} rejoined the session`, false, true);
            showNotification(`${data.alias} has rejoined the session`);
        }
        else if(data.type === 'voice') {
            appendMessage('Voice message', false, false, data.timestamp, data.audio);
        }
        else if(data.type === 'danger') {
            setDangerStatus(data.clientAlias, data.inDanger);
            if (data.inDanger && data.position) {
                addDangerMarker(data.position, data.clientAlias);
                appendMessage(`${data.clientAlias} is in danger!`, false, true);
                
                // If this is a host being flagged by someone else
                if (data.flaggedBy && data.clientAlias !== myAlias) {
                    // Add host in danger badge
                    const userCards = document.querySelectorAll('.user-card');
                    userCards.forEach(card => {
                        const nameElement = card.querySelector('.user-name');
                        if (nameElement && nameElement.textContent.includes(data.clientAlias)) {
                            let badge = card.querySelector('.host-in-danger');
                            if (!badge) {
                                badge = document.createElement('span');
                                badge.className = 'host-in-danger';
                                badge.textContent = 'Host â€” In Danger (manual SOS required)';
                                nameElement.appendChild(badge);
                            }
                        }
                    });
                    showNotification(`${data.clientAlias} flagged in danger â€” manual response required`, true);
                }
            } else {
                clearDangerMarkers(data.clientAlias);
            }
        }
        else if(data.type === 'sos') {
            setDangerStatus(data.clientAlias, true);
            if (data.position) {
                addDangerMarker(data.position, data.clientAlias);
            }
            
            let message = `EMERGENCY: ${data.clientAlias} sent an SOS!`;
            if (data.automatic && data.timerExpired) {
                message = `EMERGENCY: ${data.clientAlias} sent an automatic SOS after timer expired!`;
            } else if (data.manual) {
                message = `EMERGENCY: ${data.clientAlias} sent a manual SOS!`;
            }
            
            appendMessage(message, false, true);
            
            // Play immediate alert
            const alertMessage = `EMERGENCY: ${data.clientAlias} needs help!`;
            showNotification(alertMessage, true);
            if ('speechSynthesis' in window) {
                const speech = new SpeechSynthesisUtterance(alertMessage);
                window.speechSynthesis.speak(speech);
            }
        }
    });
    
    connection.on('close', () => {
        updateStatus('Peer disconnected', false);
        if(peerMarker){ map.removeLayer(peerMarker); peerMarker=null; }
        appendMessage(`${peerAlias} left the session`, false, true);
        showNotification('Peer disconnected');
        removePeerCard();
        
        // Clear danger status for disconnected peer
        if (peerAlias) {
            setDangerStatus(peerAlias, false);
            clearDangerMarkers(peerAlias);
        }
        
        // If we were not host and host disconnected, become new host
        if(!isHost) {
            isHost = true;
            hostIndicator.classList.remove('hidden');
            // Add host badge
            const yourNameDisplay = document.getElementById('your-name-display');
            let hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
            if (!hostBadge) {
                hostBadge = document.createElement('span');
                hostBadge.className = 'host-exempt-badge';
                hostBadge.textContent = 'Host (exempt from auto-SOS)';
                yourNameDisplay.appendChild(hostBadge);
            }
            safeSend({ type: 'host-migration' });
            appendMessage(`You are now the host of the session`, false, true);
            showNotification('You are now the host');
        }
    });
    
    connection.on('error', (err) => { 
        console.error('data channel error', err); 
        showNotification('Data channel error: ' + err.message, true); 
    });
}

function updatePeerAlias(data){
    removePeerCard();
    const alias = (data && data.alias) ? String(data.alias) : generateAnonAlias();
    const div = document.createElement('div'); 
    div.className = 'user-card peer-card fade-in';
    
    // Check if this is a host
    let hostBadgeHTML = '';
    if (data.isHost) {
        hostBadgeHTML = '<span class="host-exempt-badge">Host (exempt from auto-SOS)</span>';
    }
    
    div.innerHTML = `<div class="user-avatar">${alias.charAt(0)}</div>
        <div class="user-info">
            <div class="user-name">${alias} ${hostBadgeHTML} <span class="duration-badge"><i class="fas fa-clock"></i> <span class="peer-duration">0s</span></span></div>
            <div class="location-sharing">
                <span class="dot"></span>
                <span><i class="fas fa-location-slash"></i> Location not shared</span>
            </div>
            <div style="margin-top:10px"><span class="status-dot"></span> Online</div>
        </div>`;
    const youCard = document.getElementById('you-card');
    userList.insertBefore(div, youCard.nextSibling);
    
    // Start peer duration timer
    const peerStart = Date.now();
    if (peerDurationInterval) clearInterval(peerDurationInterval);
    peerDurationInterval = setInterval(() => {
        const elapsed = Date.now() - peerStart;
        const durationElement = div.querySelector('.peer-duration');
        if (durationElement) {
            durationElement.textContent = formatDuration(elapsed);
        }
    }, 1000);
}

function removePeerCard() {
    const peerCards = userList.querySelectorAll('.peer-card');
    peerCards.forEach(card => card.remove());
    if (peerDurationInterval) {
        clearInterval(peerDurationInterval);
        peerDurationInterval = null;
    }
}

function updatePeerLocation(d){
    const latitude = Number(d.latitude), longitude = Number(d.longitude);
    if(isNaN(latitude) || isNaN(longitude)) return;
    
    // Update peer location indicator
    const peerCard = document.querySelector('.peer-card');
    if(peerCard) {
        peerCard.querySelector('.location-sharing').innerHTML = `
            <span class="dot"></span>
            <span><i class="fas fa-location-dot"></i> Location shared</span>
        `;
    }
    
    if(peerMarker) map.removeLayer(peerMarker);
    peerMarker = L.marker([latitude, longitude]).addTo(map).bindPopup(`<b>${peerAlias}'s Location</b><br>Lat: ${latitude.toFixed(6)}, Lng: ${longitude.toFixed(6)}`).openPopup();
    
    // Center map if both locations are available
    if(myMarker) {
        const bounds = L.latLngBounds([
            [myMarker.getLatLng().lat, myMarker.getLatLng().lng],
            [latitude, longitude]
        ]);
        map.fitBounds(bounds, { padding: [50, 50] });
    } else {
        map.setView([latitude, longitude], 13);
    }
    
    // Update danger status if user has moved
    if (peerAlias && dangerStatus[peerAlias]) {
        // Check if user has moved more than 1 meter
        if (lastPosition) {
            const movedDistance = calculateDistance(
                lastPosition.latitude, lastPosition.longitude,
                latitude, longitude
            );
            if (movedDistance > 1) { // More than 1 meter
                setDangerStatus(peerAlias, false);
                safeSend({
                    type: 'danger',
                    clientAlias: peerAlias,
                    inDanger: false,
                    timestamp: Date.now()
                });
            }
        }
    }
}

/* share location */
function shareMyLocation(){
    if(!peer) {
        showNotification('No active session. Create or join a session first.', true);
        return;
    }
    if(!navigator.geolocation){ showNotification('Geolocation not supported', true); return; }
    shareLocationBtn.disabled = true;
    shareLocationBtn.innerHTML = `<i class="fas fa-sync fa-spin"></i> Getting...`;
    navigator.geolocation.getCurrentPosition(pos => {
        const latitude = pos.coords.latitude, longitude = pos.coords.longitude;
        const myCard = document.getElementById('you-card');
        myCard.querySelector('.location-sharing').innerHTML = `
            <span class="dot"></span>
            <span><i class="fas fa-location-dot"></i> Location shared</span>
        `;
        if(myMarker) map.removeLayer(myMarker);
        myMarker = L.marker([latitude, longitude]).addTo(map).bindPopup(`<b>Your Location</b><br>Lat: ${latitude.toFixed(6)}, Lng: ${longitude.toFixed(6)}`).openPopup();
        
        // Update coordinates display
        coordinatesDisplay.textContent = `Coordinates: Lat ${latitude.toFixed(6)}, Lng ${longitude.toFixed(6)}`;
        
        // Center map if peer location is available
        if(peerMarker) {
            const bounds = L.latLngBounds([
                [latitude, longitude],
                [peerMarker.getLatLng().lat, peerMarker.getLatLng().lng]
            ]);
            map.fitBounds(bounds, { padding: [50, 50] });
        } else {
            map.setView([latitude, longitude], 13);
        }
        
        if(conn && conn.open) {
            safeSend({ 
                type:'location', 
                latitude: latitude, 
                longitude: longitude, 
                clientAlias: myAlias,
                isHost: isHost  // Send host status with location
            });
        }
        shareLocationBtn.disabled = false;
        shareLocationBtn.innerHTML = `<i class="fas fa-location-dot"></i> Share Location`;
        showNotification('Location shared');
        locationControls.classList.remove('hidden');
        locationShared = true;
        
        // Update last position for danger monitoring
        lastPosition = { latitude, longitude };
        lastPositionTime = Date.now();
        
        // Clear danger status if user has moved
        if (dangerStatus[myAlias]) {
            // If we have previous position, check distance
            if (lastPosition && sosOriginalPosition) {
                const movedDistance = calculateDistance(
                    sosOriginalPosition.latitude, sosOriginalPosition.longitude,
                    latitude, longitude
                );
                if (movedDistance > 1) { // More than 1 meter
                    setDangerStatus(myAlias, false);
                    if (voiceAlertInterval) {
                        clearInterval(voiceAlertInterval);
                        voiceAlertInterval = null;
                    }
                    safeSend({
                        type: 'danger',
                        clientAlias: myAlias,
                        inDanger: false,
                        timestamp: Date.now()
                    });
                }
            }
        }
    }, err => {
        console.error('Geolocation error', err);
        shareLocationBtn.disabled = false;
        shareLocationBtn.innerHTML = `<i class="fas fa-location-dot"></i> Share Location`;
        showNotification('Could not get location (enable location services)', true);
        
        // Show warning about high-accuracy location
        if (err.code === 1) { // PERMISSION_DENIED
            showNotification('Location permission denied. Please enable location services.', true);
        } else if (err.code === 2) { // POSITION_UNAVAILABLE
            showNotification('High-accuracy location unavailable â€” movement detection may be less precise', true);
        } else if (err.code === 3) { // TIMEOUT
            showNotification('Location request timed out. Please try again.', true);
        }
    }, { enableHighAccuracy:true, maximumAge:30000, timeout:10000 });
}

// Calculate distance between two coordinates in meters
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth radius in meters
    const Ï†1 = lat1 * Math.PI/180;
    const Ï†2 = lat2 * Math.PI/180;
    const Î”Ï† = (lat2-lat1) * Math.PI/180;
    const Î”Î» = (lon2-lon1) * Math.PI/180;
    const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
            Math.cos(Ï†1) * Math.cos(Ï†2) *
            Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

/* update location */
updateLocationBtn.addEventListener('click', () => {
    shareMyLocation();
    updateLocationBtn.innerHTML = `<i class="fas fa-sync fa-spin"></i> Updating...`;
    showNotification('Updating your location...');
});

/* stop sharing location */
stopSharingBtn.addEventListener('click', () => {
    if(myMarker) {
        map.removeLayer(myMarker);
        myMarker = null;
    }
    const myCard = document.getElementById('you-card');
    myCard.querySelector('.location-sharing').innerHTML = `
        <span class="dot"></span>
        <span><i class="fas fa-location-slash"></i> Location not shared</span>
    `;
    coordinatesDisplay.textContent = 'Coordinates: Not available';
    locationControls.classList.add('hidden');
    locationShared = false;
    showNotification('Stopped sharing your location');
});

/* stop session */
function stopSession(){
    // Clear SOS timer if active
    if (sosTimerInterval) {
        clearInterval(sosTimerInterval);
        sosTimerInterval = null;
    }
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }
    sosOverlay.classList.add('hidden');
    
    destroyExistingPeer();
    localStorage.removeItem('session_active');
    localStorage.removeItem('session_role');
    localStorage.removeItem('session_code');
    sessionRoleCached = null;
    setupCard.classList.remove('hidden');
    sessionCard.classList.add('hidden');
    displayCodeInput.value = '';
    updateStatus('Ready to connect', false);
    if(myMarker){ map.removeLayer(myMarker); myMarker=null; }
    if(peerMarker){ map.removeLayer(peerMarker); peerMarker=null; }
    userList.innerHTML = `<div class="user-card" id="you-card">
        <div class="user-avatar">Y</div>
        <div class="user-info">
            <div class="user-name" id="your-name-display">You <span class="duration-badge"><i class="fas fa-clock"></i> <span id="your-duration">0s</span></span></div>
            <div class="location-sharing">
                <span class="dot"></span>
                <span><i class="fas fa-location-slash"></i> Location not shared</span>
            </div>
            <div style="margin-top:10px"><span class="status-dot"></span> Online</div>
        </div>
    </div>`;
    chatMessages.innerHTML = '<div class="message-system">Welcome to SecureHat! Start by creating or joining a session.</div>';
    if(timerInterval) clearInterval(timerInterval);
    sessionTimer.textContent = '00:00:00';
    locationControls.classList.add('hidden');
    locationShared = false;
    sosButton.classList.add('hidden');
    voiceContainer.classList.add('hidden');
    
    // Clear danger monitoring
    if (dangerCheckInterval) clearInterval(dangerCheckInterval);
    if (voiceAlertInterval) clearInterval(voiceAlertInterval);
    dangerStatus = {};
    lastPosition = null;
    lastPositionTime = null;
    
    // Clear danger markers
    dangerMarkers.forEach(markerInfo => {
        clearInterval(markerInfo.marker.flashInterval);
        map.removeLayer(markerInfo.marker);
    });
    dangerMarkers = [];
    
    // Remove host indicator and badge
    hostIndicator.classList.add('hidden');
    isHost = false;
    dangerAlert.classList.add('hidden');
    
    // Remove host badge from user card
    const yourNameDisplay = document.getElementById('your-name-display');
    const hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
    if (hostBadge) hostBadge.remove();
    
    // Remove SOS markers
    if (window.sosOriginalMarker) {
        map.removeLayer(window.sosOriginalMarker);
        window.sosOriginalMarker = null;
    }
    if (window.sosCurrentMarker) {
        map.removeLayer(window.sosCurrentMarker);
        window.sosCurrentMarker = null;
    }
    
    showNotification('Session stopped');
}

function setControlsDisabled(state){
    [createSessionBtn, openJoinBtn, resumeSessionBtn, copyCodeBtn].forEach(b => { if(b) b.disabled = state; });
}

/* ========= Modal fixed behavior (stop modal) ========= */
function showStopModal(){
    const sessionActive = localStorage.getItem('session_active') === 'true';
    if(!sessionActive){ showNotification('No active session to stop', true); return; }
    stopConfirmation.classList.add('show');
    confirmStopBtn.focus();
}

function hideStopModal(){ stopConfirmation.classList.remove('show'); }

stopSessionBtn.addEventListener('click', (e) => { showStopModal(); });
confirmStopBtn.addEventListener('click', (e) => { hideStopModal(); setTimeout(()=> stopSession(), 120); });
cancelStopBtn.addEventListener('click', hideStopModal);
stopConfirmation.addEventListener('click', (e) => { if(e.target === stopConfirmation) hideStopModal(); });
const confirmationBox = stopConfirmation.querySelector('.confirmation-box');
if(confirmationBox) confirmationBox.addEventListener('click', (e)=> e.stopPropagation());
window.addEventListener('keydown', (e) => { if(e.key === 'Escape' && stopConfirmation.classList.contains('show')) hideStopModal(); });

/* ========= Resume & load handling ========= */
window.addEventListener('DOMContentLoaded', () => {
    const showRealName = localStorage.getItem('show_real_name') === 'true';
    showRealNameToggle.checked = showRealName;
    const sessionCode = localStorage.getItem('session_code');
    const sessionActive = localStorage.getItem('session_active') === 'true';
    const sessionRole = localStorage.getItem('session_role');
    if(sessionCode && sessionActive && sessionRole){
        displayCodeInput.value = sessionCode;
        setupCard.classList.remove('hidden');
        sessionCard.classList.remove('hidden');
        updateStatus('Session active. Type your name and press Reconnect.', false);
        sessionRoleCached = sessionRole;
        if(sessionRole === 'host') {
            hostIndicator.classList.remove('hidden');
            isHost = true;
            // Add host badge to user card
            const yourNameDisplay = document.getElementById('your-name-display');
            let hostBadge = yourNameDisplay.querySelector('.host-exempt-badge');
            if (!hostBadge) {
                hostBadge = document.createElement('span');
                hostBadge.className = 'host-exempt-badge';
                hostBadge.textContent = 'Host (exempt from auto-SOS)';
                yourNameDisplay.appendChild(hostBadge);
            }
        }
    } else {
        setupCard.classList.remove('hidden');
        sessionCard.classList.add('hidden');
        updateStatus('Ready to connect', false);
    }
    
    // Request notification permission
    requestNotificationPermission();
    
    // Setup voice recording
    setupVoiceRecording();
    
    // Initialize movement detection
    initializeMovementDetection();
});

function updateYourNameDisplay() {
    const realName = localStorage.getItem('local_real_name') || 'You';
    yourNameDisplay.textContent = realName;
}

showRealNameToggle.addEventListener('change', () => {
    localStorage.setItem('show_real_name', showRealNameToggle.checked);
});

/* ========= Event listeners ========= */
createSessionBtn.addEventListener('click', () => {
    if(!sessionCodeInput.value.trim()){
        showNotification('Enter or generate a session code before creating', true);
        return;
    }
    startSession(true);
});

openJoinBtn.addEventListener('click', () => {
    joinModal.classList.add('show');
    joinModal.setAttribute('aria-hidden', 'false');
});

resumeSessionBtn.addEventListener('click', () => {
    const persistedName = localStorage.getItem('local_real_name') || '';
    if (persistedName) realNameInput.value = persistedName;
    if (!realNameInput.value.trim()) {
        showNotification('Type your real name to reconnect.', true);
        return;
    }
    const persistedCode = localStorage.getItem('session_code') || displayCodeInput.value;
    if (persistedCode) sessionCodeInput.value = persistedCode;
    const isHost = (localStorage.getItem('session_role') === 'host');
    startSession(isHost);
});

copyCodeBtn.addEventListener('click', () => {
    const txt = displayCodeInput.value || sessionCodeInput.value || '';
    if(txt) copyToClipboard(txt); else showNotification('No code available to copy', true);
});

shareLocationBtn.addEventListener('click', shareMyLocation);

/* Chat send */
chatSend.addEventListener('click', () => {
    const txt = chatInput.value.trim();
    if(!txt) return;
    appendMessage(`${myAlias}: ${txt}`, true);
    if (conn && conn.open) {
        safeSend({ type:'chat', text: txt, clientAlias: myAlias });
    }
    chatInput.value = '';
});

chatInput.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        chatSend.click();
    }
});

window.addEventListener('beforeunload', (e) => {
    const sessionActive = localStorage.getItem('session_active') === 'true';
    if(sessionActive){
        e.preventDefault();
        e.returnValue = '';
    }
});

// Clean up device motion listener on unload
window.addEventListener('unload', () => {
    if (deviceMotionSupported) {
        window.removeEventListener('devicemotion', handleDeviceMotion);
    }
    
    // Clear any active SOS timer
    if (sosTimerInterval) {
        clearInterval(sosTimerInterval);
        sosTimerInterval = null;
    }
    
    if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }
});
</script>
</body>
</html>
