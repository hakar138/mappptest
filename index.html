<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solar Hat â€” Smart Wearable Guide</title>
  
  <!-- Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Leaflet CSS (for embedded map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    /* Existing styles... */

    /* Time-based themes */
    :root {
      --morning-bg: #f0f9ff;
      --morning-accent: #0ea5a4;
      --morning-accent-2: #2b9df4;
      --morning-card: #ffffff;
      --morning-text: #0f1a2f;
      
      --afternoon-bg: #fef6e4;
      --afternoon-accent: #f582ae;
      --afternoon-accent-2: #8bd3dd;
      --afternoon-card: #fffffe;
      --afternoon-text: #001858;
      
      --evening-bg: #fff5f7;
      --evening-accent: #ff6b6b;
      --evening-accent-2: #ff9e7d;
      --evening-card: #ffffff;
      --evening-text: #0f1a2f;
      
      --night-bg: #0a0e23;
      --night-accent: #38bdf8;
      --night-accent-2: #818cf8;
      --night-card: #1a1f3d;
      --night-text: #e0e7ff;
    }

    body {
      transition: background-color 1.5s ease, color 1.5s ease;
    }

    /* Morning Theme (Default) */
    body.time-morning {
      --page-bg: var(--morning-bg);
      --nav-bg: var(--morning-card);
      --muted: #5e718d;
      --text: var(--morning-text);
      --accent: var(--morning-accent);
      --accent-2: var(--morning-accent-2);
      --accent-light: #d1f0ef;
      --card-bg: var(--morning-card);
    }

    /* Afternoon Theme */
    body.time-afternoon {
      --page-bg: var(--afternoon-bg);
      --nav-bg: var(--afternoon-card);
      --muted: #5f6c7b;
      --text: var(--afternoon-text);
      --accent: var(--afternoon-accent);
      --accent-2: var(--afternoon-accent-2);
      --accent-light: #fce4ed;
      --card-bg: var(--afternoon-card);
    }

    /* Evening Theme */
    body.time-evening {
      --page-bg: var(--evening-bg);
      --nav-bg: var(--evening-card);
      --muted: #5e718d;
      --text: var(--evening-text);
      --accent: var(--evening-accent);
      --accent-2: var(--evening-accent-2);
      --accent-light: #ffe5e5;
      --card-bg: var(--evening-card);
    }

    /* Night Theme */
    body.time-night {
      --page-bg: var(--night-bg);
      --nav-bg: var(--night-card);
      --muted: #8b98c6;
      --text: var(--night-text);
      --accent: var(--night-accent);
      --accent-2: var(--night-accent-2);
      --accent-light: rgba(56, 189, 248, 0.15);
      --card-bg: var(--night-card);
      --glass: rgba(26, 31, 61, 0.6);
      --glass-border: rgba(224, 231, 255, 0.06);
    }

    /* Apply card background variable */
    .status-section, .card {
      background: var(--card-bg);
    }

    /* Night-specific styles */
    body.time-night footer.footer {
      background: linear-gradient(180deg, rgba(26,31,61,0.35), rgba(26,31,61,0.25));
      border-top: 1px solid rgba(224, 231, 255, 0.1);
    }

    body.time-night .weather-glass {
      background: linear-gradient(180deg, rgba(26, 31, 61, 0.72), rgba(26, 31, 61, 0.6)) !important;
      border: 1px solid rgba(224, 231, 255, 0.1);
    }

    /* New weather icons */
    .weather-icon.night {
      color: #e0e7ff;
    }

    /* Map marker for night */
    body.time-night .user-location-marker {
      filter: drop-shadow(0 0 4px rgba(56, 189, 248, 0.7));
    }

    /* Rest of existing styles... */
  </style>
</head>
<body>
  <!-- Rest of HTML... -->

  <script>
    /************************************************************************
     * NEW FEATURES:
     * 1. Enhanced Map Visualization:
     *    - Pulsing accuracy visualization
     *    - Dynamic zoom based on accuracy
     *    - Improved marker positioning
     *
     * 2. Night-time Weather:
     *    - Moon icon for clear nights
     *    - Cloudy/rainy night visuals
     *    - Time-based weather icons
     *
     * 3. Time-based Color Themes:
     *    - Morning, afternoon, evening, and night themes
     *    - Dynamic background and accent colors
     *    - Smooth transitions
     ************************************************************************/

    /* === Time-based Theme Function === */
    function setTimeOfDayTheme() {
      const hour = new Date().getHours();
      document.body.classList.remove('time-morning', 'time-afternoon', 'time-evening', 'time-night');
      
      if (hour >= 5 && hour < 12) {
        document.body.classList.add('time-morning');
      } else if (hour >= 12 && hour < 17) {
        document.body.classList.add('time-afternoon');
      } else if (hour >= 17 && hour < 20) {
        document.body.classList.add('time-evening');
      } else {
        document.body.classList.add('time-night');
      }
    }
    
    // Set initial theme and update every hour
    setTimeOfDayTheme();
    setInterval(setTimeOfDayTheme, 3600000);

    /* === Enhanced Map Functions === */
    function ensureMap(lat, lon) {
      if (mapContainer.style.display !== 'block') { 
        mapContainer.style.display = 'block'; 
        mapContainer.setAttribute('aria-hidden','false');
        mapContainer.animate([
          { opacity: 0, height: 0 },
          { opacity: 1, height: '280px' }
        ], { duration: 500, easing: 'ease-out' });
      }
      if (!map) {
        map = L.map('map', { zoomControl:true }).setView([lat, lon], INITIAL_ZOOM);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19, attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
        }).addTo(map);
      }
    }

    function updateAccuracyVisual(lat, lon, accuracy) {
      // Remove existing visual if present
      if (accuracyVisual) {
        accuracyVisual.remove();
      }
      
      // Create new visual
      accuracyVisual = L.circle([lat, lon], {
        radius: accuracy,
        color: 'var(--accent)',
        fillColor: 'var(--accent-light)',
        fillOpacity: 0.2,
        className: 'accuracy-visual'
      }).addTo(map);
    }

    function updateMap(lat, lon, accuracy) {
      if (!map) ensureMap(lat, lon);
      const pt = [lat, lon];
      
      // Create marker if not exists
      if (!userMarker) {
        userMarker = L.marker(pt, { 
          icon: L.divIcon({ 
            className:'user-location-marker', 
            html:'<div style="width:16px;height:16px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 6px var(--accent-light);"></div>', 
            iconSize:[30,30], 
            iconAnchor:[15,15] 
          }) 
        }).addTo(map);
      } else {
        userMarker.setLatLng(pt);
      }
      
      // Create accuracy circle if not exists
      if (!accuracyCircle) {
        accuracyCircle = L.circle(pt, { 
          radius: accuracy, 
          color:'var(--accent)', 
          fillColor:'var(--accent-light)', 
          fillOpacity:0.22 
        }).addTo(map);
      } else { 
        accuracyCircle.setLatLng(pt); 
        accuracyCircle.setRadius(accuracy); 
      }
      
      // Update accuracy visual with pulsing effect
      updateAccuracyVisual(lat, lon, accuracy);
      
      // Adjust map view based on accuracy
      const zoomLevel = calculateZoomLevel(accuracy);
      map.setView(pt, zoomLevel);
    }

    function calculateZoomLevel(accuracy) {
      if (accuracy > 1000) return 12;
      if (accuracy > 500) return 13;
      if (accuracy > 200) return 14;
      if (accuracy > 100) return 15;
      if (accuracy > 50) return 16;
      return 17;
    }

    /* === Night-time Weather Enhancements === */
    const weatherCodeMap = {
      // Day versions
      0:['Clear sky','â˜€ï¸'],1:['Mainly clear','ğŸŒ¤ï¸'],2:['Partly cloudy','â›…'],3:['Overcast','â˜ï¸'],
      45:['Fog','ğŸŒ«ï¸'],48:['Rime fog','ğŸŒ«ï¸'],51:['Light drizzle','ğŸŒ¦ï¸'],53:['Moderate drizzle','ğŸŒ§ï¸'],
      55:['Dense drizzle','ğŸŒ§ï¸'],61:['Slight rain','ğŸŒ§ï¸'],63:['Moderate rain','ğŸŒ§ï¸'],65:['Heavy rain','ğŸŒ§ï¸'],
      71:['Slight snow','â„ï¸'],73:['Moderate snow','â„ï¸'],75:['Heavy snow','â„ï¸'],80:['Rain showers','ğŸŒ¦ï¸'],
      95:['Thunderstorm','â›ˆï¸'],
      
      // Night versions
      '0-night':['Clear sky','ğŸŒ™'],
      '1-night':['Mainly clear','ğŸŒ™â˜ï¸'],
      '2-night':['Partly cloudy','ğŸŒ™â›…'],
      '3-night':['Overcast','ğŸŒ™â˜ï¸'],
      '45-night':['Fog','ğŸŒ«ï¸'],
      '48-night':['Rime fog','ğŸŒ«ï¸'],
      '51-night':['Light drizzle','ğŸŒ§ï¸'],
      '53-night':['Moderate drizzle','ğŸŒ§ï¸'],
      '55-night':['Dense drizzle','ğŸŒ§ï¸'],
      '61-night':['Slight rain','ğŸŒ§ï¸'],
      '63-night':['Moderate rain','ğŸŒ§ï¸'],
      '65-night':['Heavy rain','ğŸŒ§ï¸'],
      '71-night':['Slight snow','â„ï¸'],
      '73-night':['Moderate snow','â„ï¸'],
      '75-night':['Heavy snow','â„ï¸'],
      '80-night':['Rain showers','ğŸŒ§ï¸'],
      '95-night':['Thunderstorm','â›ˆï¸']
    };

    async function fetchOpenMeteoWeather(lat, lon, speakOnFetch=false) {
      try {
        const ep = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&current_weather=true&hourly=relativehumidity_2m&timezone=auto`;
        if (wSource) wSource.textContent = 'Open-Meteo';
        if (wIcon) wIcon.innerHTML = '<span class="loading"></span>';
        if (wTemp) wTemp.textContent = 'â€”';
        if (wCond) wCond.textContent = 'Loading...';
        
        const resp = await fetch(ep, {cache:'no-store'});
        if (!resp.ok) throw new Error('Open-Meteo error');
        const data = await resp.json();
        if (!data || !data.current_weather) throw new Error('No current_weather');

        const cw = data.current_weather;
        const temperature = Number(cw.temperature);
        const wind = Number(cw.windspeed);
        const code = Number(cw.weathercode);
        const isNight = cw.is_day === 0;

        // Get weather condition
        const conditionKey = isNight ? `${code}-night` : code;
        const mapVal = weatherCodeMap[conditionKey] || weatherCodeMap[code] || ['Clear','ğŸŒ¤ï¸'];
        const conditionText = mapVal[0], conditionIcon = mapVal[1];

        const weather = {
          temperatureC: temperature,
          windKmh: `${wind} km/h`,
          condition: conditionText,
          icon: conditionIcon,
          isNight: isNight
        };

        // Find nearest humidity
        if (data.hourly && data.hourly.time && data.hourly.relativehumidity_2m) {
          const times = data.hourly.time, rh = data.hourly.relativehumidity_2m;
          let bestIdx = 0, bestDiff = Infinity;
          for (let i=0; i<times.length; i++){
            const t = new Date(times[i]);
            const diff = Math.abs(t - new Date());
            if (diff < bestDiff) { bestIdx = i; bestDiff = diff; }
          }
          weather.humidity = (typeof rh[bestIdx] !== 'undefined') ? `${Math.round(rh[bestIdx])}%` : 'â€”';
        }

        applyWeather(weather, 'Open-Meteo');
        if (speakOnFetch) speak(`Current temperature is ${temperature.toFixed(1)} degrees Celsius and ${conditionText}.`, {force:true});
        if (tempEl) tempEl.textContent = `${temperature.toFixed(1)} Â°C`;
        return true;
      } catch (err) {
        console.warn('Open-Meteo failed', err);
        // Fallback simulated weather with night detection
        const hour = new Date().getHours();
        const isNight = hour >= 20 || hour < 5;
        const sim = simulateWeatherFor(lat, lon, isNight);
        applyWeather(sim, 'Simulated (fallback)');
        return false;
      }
    }

    function applyWeather(w, source='Simulated') {
      if (wTemp) wTemp.textContent = `${w.temperatureC.toFixed(1)}Â°C`;
      if (wIcon) {
        wIcon.textContent = w.icon || 'â€”';
        wIcon.className = w.isNight ? 'weather-icon night' : 'weather-icon';
      }
      if (wCond) wCond.textContent = w.condition || 'â€”';
      if (wHum) wHum.textContent = w.humidity || 'â€”';
      if (wWind) wWind.textContent = w.windKmh || 'â€”';
      if (wSource) wSource.textContent = source || 'â€”';
      if (wExtras) wExtras.textContent = `Updated ${new Date().toLocaleTimeString()}`;

      // Update weather glass based on condition and time
      const c = (w.condition || '').toLowerCase();
      weatherGlass.classList.remove('bg-sunny','bg-cloudy','bg-rain','bg-snow');
      
      if (w.isNight) {
        weatherGlass.classList.add('bg-night');
      } else if (c.includes('rain') || c.includes('drizzle') || c.includes('thunder')) {
        weatherGlass.classList.add('bg-rain');
      } else if (c.includes('snow')) {
        weatherGlass.classList.add('bg-snow');
      } else if (c.includes('clear') || c.includes('sun')) {
        weatherGlass.classList.add('bg-sunny');
      } else {
        weatherGlass.classList.add('bg-cloudy');
      }

      // Animation for weather update
      weatherGlass.animate([{ transform: 'translateY(4px)', opacity: 0.96 }, { transform: 'translateY(0)', opacity:1 }], 
                          { duration: 420, easing: 'cubic-bezier(.2,.9,.2,1)' });
    }

    /* === Simulated weather with night detection === */
    function simulateWeatherFor(lat, lon, isNight=false) {
      // Deterministic pseudo-random based on coords
      const seed = Math.abs(Math.floor((lat*10000) ^ (lon*10000)));
      function rnd(min,max) { 
        const x = Math.sin(seed + min*9973 + max*7919) * 43758.5453; 
        const n = Math.abs(x - Math.floor(x)); 
        return min + n*(max-min); 
      }
      
      const latAbs = Math.abs(lat);
      const base = 28 - (latAbs/90)*40;
      const t = base + rnd(-4,4);
      const humidity = Math.max(8, Math.min(95, Math.round(50 + rnd(-28,28))));
      const wind = Math.max(0, +(rnd(0,22)).toFixed(1));
      const r = rnd(0,100);
      
      let cond = 'Partly cloudy';
      if (r < 10 && t < 2) cond = 'Snow';
      else if (r < 25 && t < 15) cond = 'Light rain';
      else if (r < 55) cond = (t > 25 ? 'Sunny' : 'Partly cloudy');
      else cond = 'Cloudy';
      
      let icon = 'â˜ï¸';
      if (cond.includes('Snow')) icon = 'â„ï¸';
      else if (cond.includes('rain')) icon = 'ğŸŒ§ï¸';
      else if (cond.includes('Sunny')) icon = 'â˜€ï¸';
      else if (cond.includes('Partly cloudy')) icon = 'â›…';
      
      // Night adjustments
      if (isNight) {
        if (cond.includes('Clear') || cond.includes('Sunny')) {
          icon = 'ğŸŒ™';
          cond = 'Clear night';
        } else if (cond.includes('Partly cloudy')) {
          icon = 'ğŸŒ™â›…';
          cond = 'Partly cloudy';
        }
      }
      
      return { 
        temperatureC: Number(t.toFixed(1)), 
        humidity: `${humidity}%`, 
        windKmh: `${wind} km/h`, 
        condition: cond, 
        icon,
        isNight
      };
    }

    /* === Initialize Time-based Theme === */
    setTimeOfDayTheme();

    // Rest of existing script...
  </script>
</body>
</html>
